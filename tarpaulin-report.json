{"files":[{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","derive","src","form_data","builder.rs"],"content":"use super::Field;\nuse proc_macro2::{Ident, TokenStream};\nuse syn::Generics;\n\npub(super) struct FormDataBuilder<'a> {\n\tpub(super) name: &'a Ident,\n\tpub(super) err_ident: &'a Ident,\n\tpub(super) ident: Ident,\n\tpub(super) generics: &'a Generics,\n\tpub(super) fields: &'a [Field]\n}\n\nimpl<'a> FormDataBuilder<'a> {\n\tpub(super) fn gen_struct(&self) -> TokenStream {\n\t\tlet ident = &self.ident;\n\t\tlet (impl_gen, _, were) = self.generics.split_for_impl();\n\n\t\tlet field_names = self.fields.iter().map(|f| &f.ident);\n\t\tlet field_types = self.fields.iter().map(|f| &f.ty);\n\n\t\tquote! {\n\t\t\t#[doc(hidden)]\n\t\t\tstruct #ident #impl_gen #were {\n\t\t\t\t#( #field_names: Option<#field_types> ),*\n\t\t\t}\n\t\t}\n\t}\n\n\tpub(super) fn gen_default_impl(&self) -> TokenStream {\n\t\tlet ident = &self.ident;\n\t\tlet (impl_gen, ty_gen, were) = self.generics.split_for_impl();\n\n\t\tlet field_names = self.fields.iter().map(|f| &f.ident);\n\n\t\tquote! {\n\t\t\timpl #impl_gen Default for #ident #ty_gen #were {\n\t\t\t\tfn default() -> Self {\n\t\t\t\t\tSelf {\n\t\t\t\t\t\t#( #field_names: None ),*\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpub(super) fn gen_builder_impl(&self) -> TokenStream {\n\t\tlet name = &self.name;\n\t\tlet err_ident = &self.err_ident;\n\t\tlet ident = &self.ident;\n\t\tlet (impl_gen, ty_gen, were) = self.generics.split_for_impl();\n\n\t\tlet field_names = self.fields.iter().map(|f| &f.ident).collect::<Vec<_>>();\n\t\tlet field_types = self.fields.iter().map(|f| &f.ty);\n\n\t\tquote! {\n\t\t\timpl #impl_gen ::gotham_formdata::internal::FormDataBuilder for #ident #ty_gen #were {\n\t\t\t\ttype Data = #name #ty_gen;\n\t\t\t\ttype Err = #err_ident;\n\n\t\t\t\tfn add_entry<'a>(\n\t\t\t\t\t\t&'a mut self,\n\t\t\t\t\t\tname: ::std::borrow::Cow<'a, str>,\n\t\t\t\t\t\tvalue: ::gotham_formdata::value::Value<'a, ::gotham_formdata::Error<Self::Err>>\n\t\t\t\t) -> ::gotham_formdata::internal::FormDataBuilderFuture<'a, Self::Err> {\n\t\t\t\t\t#[allow(unused_imports)]\n\t\t\t\t\tuse ::gotham_formdata::{conversion::prelude::*, export::{FutureExt, StreamExt}};\n\n\t\t\t\t\tasync move {\n\t\t\t\t\t\tlet name: &str = &name;\n\t\t\t\t\t\tmatch name {\n\t\t\t\t\t\t\t#(stringify!(#field_names) => {\n\t\t\t\t\t\t\t\tlog::debug!(\"Found value for field {}\", name);\n\t\t\t\t\t\t\t\tlet value_parsed = <#field_types>::convert_value(name, value).await?;\n\t\t\t\t\t\t\t\tself.#field_names.replace(value_parsed);\n\t\t\t\t\t\t\t\tOk(())\n\t\t\t\t\t\t\t},)*\n\t\t\t\t\t\t\t_ => {\n\t\t\t\t\t\t\t\tlog::debug!(\"Found an unknown field: {}\", name);\n\t\t\t\t\t\t\t\tErr(::gotham_formdata::Error::UnknownField(name.to_string()))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}.boxed()\n\t\t\t\t}\n\n\t\t\t\tfn build(self) -> Result<#name #ty_gen, ::gotham_formdata::Error<Self::Err>> {\n\t\t\t\t\tOk(#name #ty_gen {\n\t\t\t\t\t\t#( #field_names: self.#field_names.ok_or(::gotham_formdata::Error::MissingField(stringify!(#field_names).to_owned()))? ),*\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","derive","src","form_data","field.rs"],"content":"use crate::util::*;\nuse proc_macro2::{Ident, Span, TokenStream};\nuse syn::{\n\tparse::{Parse, ParseStream},\n\tpunctuated::Punctuated,\n\tspanned::Spanned,\n\tError, Expr, Result, Token, Type\n};\n\n#[allow(dead_code)]\nstruct FieldMeta {\n\tident: Ident,\n\teq_token: Token![=],\n\texpr: Expr\n}\n\nimpl Parse for FieldMeta {\n\tfn parse(input: ParseStream<'_>) -> Result<Self> {\n\t\tOk(Self {\n\t\t\tident: input.parse()?,\n\t\t\teq_token: input.parse()?,\n\t\t\texpr: input.parse()?\n\t\t})\n\t}\n}\n\npub(super) struct Field {\n\tpub(super) ident: Ident,\n\tpub(super) ty: Type,\n\tpub(super) validator: Option<TokenStream>,\n\tpub(super) validator_span: Option<Span>,\n\tpub(super) validation_error: Option<Expr>\n}\n\nimpl Field {\n\tpub(super) fn new(field: syn::Field) -> Result<Self> {\n\t\tlet span = field.span();\n\n\t\tlet mut ident = field\n\t\t\t.ident\n\t\t\t.ok_or(Error::new(span, \"Fields without an ident are not supported\"))?;\n\t\tident.set_span(Span::call_site());\n\n\t\tlet ty = field.ty;\n\t\t// unfortunately, we cannot change spans of types\n\n\t\tlet mut validator: Option<TokenStream> = None;\n\t\tlet mut validator_span: Option<Span> = None;\n\t\tlet mut validation_error: Option<Expr> = None;\n\t\tfor attr in field.attrs {\n\t\t\tif !attr.path.ends_with(\"validate\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet list = attr.parse_args_with(Punctuated::<FieldMeta, Token![,]>::parse_separated_nonempty)?;\n\t\t\t// parse_separated_nonempty guarantees that there is at least one element in the list\n\t\t\tfor meta in list.into_iter() {\n\t\t\t\tlet name = meta.ident;\n\t\t\t\tlet expr = meta.expr;\n\n\t\t\t\tlet (new_validator, new_span) = match name.to_string().as_ref() {\n\t\t\t\t\t// custom error message\n\t\t\t\t\t\"error\" => {\n\t\t\t\t\t\tif validation_error.is_some() {\n\t\t\t\t\t\t\treturn Err(Error::new(name.span(), \"'error' must not appear more than once\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalidation_error = Some(expr);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t},\n\n\t\t\t\t\t// custom validator\n\t\t\t\t\t\"validator\" => {\n\t\t\t\t\t\t// TODO this code makes sure to emit an error message pointing to the macro's\n\t\t\t\t\t\t// input, but there should be a better way to do this\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tquote_spanned! { expr.span() =>\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlet validator = #expr;\n\t\t\t\t\t\t\t\t\t::gotham_formdata::internal::assert_validator::<_, _>(&validator);\n\t\t\t\t\t\t\t\t\tvalidator\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\texpr.span()\n\t\t\t\t\t\t)\n\t\t\t\t\t},\n\n\t\t\t\t\t// min_length validator\n\t\t\t\t\t\"min_length\" => (\n\t\t\t\t\t\tquote!(::gotham_formdata::validate::MinLengthValidator::new(#expr)),\n\t\t\t\t\t\tname.span()\n\t\t\t\t\t),\n\n\t\t\t\t\t// max_length validator\n\t\t\t\t\t\"max_length\" => (\n\t\t\t\t\t\tquote!(::gotham_formdata::validate::MaxLengthValidator::new(#expr)),\n\t\t\t\t\t\tname.span()\n\t\t\t\t\t),\n\n\t\t\t\t\t// min validator\n\t\t\t\t\t\"min\" => (\n\t\t\t\t\t\tquote!(::gotham_formdata::validate::MinValidator::<#ty>::new(#expr)),\n\t\t\t\t\t\tname.span()\n\t\t\t\t\t),\n\n\t\t\t\t\t// max validator\n\t\t\t\t\t\"max\" => (\n\t\t\t\t\t\tquote!(::gotham_formdata::validate::MaxValidator::<#ty>::new(#expr)),\n\t\t\t\t\t\tname.span()\n\t\t\t\t\t),\n\n\t\t\t\t\t// regex validator\n\t\t\t\t\t\"regex\" => {\n\t\t\t\t\t\tif cfg!(not(feature = \"regex\")) {\n\t\t\t\t\t\t\treturn Err(Error::new(\n\t\t\t\t\t\t\t\tname.span(),\n\t\t\t\t\t\t\t\t\"You need to enable the 'regex-validation' feature of gotham_formdata to enable the regex validator\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet regex_ident = format_ident!(\"{}_validation_regex\", ident.to_string());\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tquote!({\n\t\t\t\t\t\t\t\tstatic #regex_ident: ::gotham_formdata::export::Lazy<::gotham_formdata::export::Regex> =\n\t\t\t\t\t\t\t\t\t\t::gotham_formdata::export::Lazy::new(|| ::gotham_formdata::export::Regex::new(#expr).expect(\"Invalid Regex\"));\n\t\t\t\t\t\t\t\t::gotham_formdata::validate::RegexValidator::new(&#regex_ident)\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\tname.span()\n\t\t\t\t\t\t)\n\t\t\t\t\t},\n\n\t\t\t\t\t// expected validator\n\t\t\t\t\t\"expected\" => (\n\t\t\t\t\t\tquote!(::gotham_formdata::validate::ExpectedValidator::new(#expr)),\n\t\t\t\t\t\tname.span()\n\t\t\t\t\t),\n\n\t\t\t\t\t_ => return Err(Error::new(name.span(), \"Unknown key for attribute validate\"))\n\t\t\t\t};\n\n\t\t\t\tvalidator = match validator {\n\t\t\t\t\tSome(old_validator) => Some(quote! {\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet first_validator = #old_validator;\n\t\t\t\t\t\t\tlet second_validator = #new_validator;\n\t\t\t\t\t\t\t::gotham_formdata::validate::CombinedValidator::new(first_validator, second_validator)\n\t\t\t\t\t\t}\n\t\t\t\t\t}),\n\t\t\t\t\tNone => Some(new_validator)\n\t\t\t\t};\n\n\t\t\t\tvalidator_span = match validator_span {\n\t\t\t\t\tSome(old_span) => Some(old_span.join(new_span).unwrap_or(old_span)),\n\t\t\t\t\tNone => Some(new_span)\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tOk(Self {\n\t\t\tident,\n\t\t\tty,\n\t\t\tvalidator,\n\t\t\tvalidator_span,\n\t\t\tvalidation_error\n\t\t})\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","derive","src","form_data","mod.rs"],"content":"use crate::util::*;\nuse proc_macro2::{Span, TokenStream};\nuse syn::{Data, DeriveInput, Error, Fields, Result};\n\nmod builder;\nuse builder::FormDataBuilder;\n\nmod field;\nuse field::Field;\n\nmod validation_error;\nuse validation_error::ValidationError;\n\npub(super) fn expand(input: DeriveInput) -> Result<TokenStream> {\n\tlet name = &input.ident;\n\tlet (impl_gen, ty_gen, were) = input.generics.split_for_impl();\n\tlet strukt = match input.data {\n\t\tData::Struct(strukt) => strukt,\n\t\t_ => {\n\t\t\treturn Err(Error::new(\n\t\t\t\tSpan::call_site(),\n\t\t\t\t\"#[derive(FormData)] can only be used on structs\"\n\t\t\t))\n\t\t},\n\t};\n\n\tlet fields = match strukt.fields {\n\t\tFields::Named(named) => named.named.into_iter().map(|field| Field::new(field)).collect_to_result()?,\n\t\tFields::Unnamed(_) => {\n\t\t\treturn Err(Error::new(\n\t\t\t\tSpan::call_site(),\n\t\t\t\t\"#[derive(FormData)] cannot be used on tuple structs\"\n\t\t\t))\n\t\t},\n\t\tFields::Unit => Vec::new()\n\t};\n\n\tlet validation_error = ValidationError {\n\t\tname,\n\t\tvis: &input.vis,\n\t\tident: format_ident!(\"{}ValidationError\", name),\n\t\tfields: &fields\n\t};\n\tlet err_ident = &validation_error.ident;\n\n\tlet builder = FormDataBuilder {\n\t\tname,\n\t\terr_ident,\n\t\tident: format_ident!(\"{}FormDataBuilder\", name),\n\t\tgenerics: &input.generics,\n\t\tfields: &fields\n\t};\n\tlet builder_ident = &builder.ident;\n\n\tlet validation_error_struct = validation_error.gen_struct();\n\n\tlet builder_struct = builder.gen_struct();\n\tlet builder_default_impl = builder.gen_default_impl();\n\tlet builder_builder_impl = builder.gen_builder_impl();\n\n\tlet field_idents = fields.iter().map(|f| &f.ident);\n\tlet field_validators = fields.iter().map(|f| {\n\t\tf.validator\n\t\t\t.as_ref()\n\t\t\t.map(|v| quote!(Some({ #v })))\n\t\t\t.unwrap_or_else(|| quote!(::std::option::Option::<()>::None))\n\t});\n\tlet field_validation_errors = fields.iter().map(|f| {\n\t\tf.validation_error\n\t\t\t.as_ref()\n\t\t\t.map(|err| quote!(Some(#err)))\n\t\t\t.unwrap_or_else(|| quote!(::std::option::Option::<String>::None))\n\t});\n\n\t// We're using this weird way of calling the validator to make type errors appear on the\n\t// validator's span, not the call site.\n\tlet field_validate_call = fields.iter().map(|f| {\n\t\tlet span = f.validator_span.unwrap_or_else(Span::call_site);\n\t\tquote_spanned! { span =>\n\t\t\t{\n\t\t\t\tfn validate_field_asserting_type<T, V>(validator: V, value: &T)\n\t\t\t\t\t-> ::std::result::Result<(), <V as ::gotham_formdata::validate::Validator<T>>::Err>\n\t\t\t\twhere\n\t\t\t\t\tT: ?Sized,\n\t\t\t\t\tV: ::gotham_formdata::validate::Validator<T>\n\t\t\t\t{\n\t\t\t\t\tvalidator.validate(value)\n\t\t\t\t}\n\t\t\t\tvalidate_field_asserting_type(validator, value)\n\t\t\t}\n\t\t}\n\t});\n\n\tlet validate_trait = format_ident!(\"Validate{}FormData\", name);\n\n\tlet mut dummy = format_ident!(\"_IMPL_FORMDATA_FOR_{}\", name);\n\tdummy.set_span(Span::call_site());\n\tOk(quote! {\n\t\t#validation_error_struct\n\n\t\t#[allow(non_upper_case_globals)]\n\t\tstatic #dummy: () = {\n\t\t\t#builder_struct\n\t\t\t#builder_default_impl\n\t\t\t#builder_builder_impl\n\n\t\t\t#[doc(hidden)]\n\t\t\ttrait #validate_trait {\n\t\t\t\tfn validate(&self) -> Result<(), #err_ident>;\n\t\t\t}\n\n\t\t\timpl #impl_gen #validate_trait for #name #ty_gen #were {\n\t\t\t\t#[doc(hidden)]\n\t\t\t\tfn validate(&self) -> Result<(), #err_ident> {\n\t\t\t\t\t::log::debug!(\"Validating Form Data for type {}\", stringify!(#name));\n\n\t\t\t\t\t#({\n\t\t\t\t\t\tconst name: &str = stringify!(#field_idents);\n\t\t\t\t\t\tlet value = &self.#field_idents;\n\t\t\t\t\t\tlet validator = #field_validators;\n\t\t\t\t\t\tlet validation_error = #field_validation_errors;\n\t\t\t\t\t\tif let Some(validator) = validator {\n\t\t\t\t\t\t\t#field_validate_call\n\t\t\t\t\t\t\t\t.map_err(|err| {\n\t\t\t\t\t\t\t\t\tmatch validation_error {\n\t\t\t\t\t\t\t\t\t\tSome(ve) => #err_ident::invalid(name, ve),\n\t\t\t\t\t\t\t\t\t\tNone     => #err_ident::invalid(name, err)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})?;\n\t\t\t\t\t\t}\n\t\t\t\t\t})*\n\n\t\t\t\t\tOk(())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\timpl #impl_gen ::gotham_formdata::FormData for #name #ty_gen #were {\n\t\t\t\ttype Err = ::gotham_formdata::Error<#err_ident>;\n\n\t\t\t\tfn parse_form_data(state: &mut ::gotham_formdata::export::State) -> ::gotham_formdata::FormDataFuture<Self> {\n\t\t\t\t\tuse ::gotham_formdata::export::FutureExt;\n\n\t\t\t\t\tlet content_type = ::gotham_formdata::internal::get_content_type(state);\n\t\t\t\t\tlet body = ::gotham_formdata::internal::get_body(state);\n\n\t\t\t\t\tasync move {\n\t\t\t\t\t\tlet content_type = content_type?;\n\t\t\t\t\t\t::log::debug!(\"Parsing Form Data for type {} with Content-Type {}\", stringify!(#name), content_type);\n\n\t\t\t\t\t\tlet res = ::gotham_formdata::internal::parse::<#builder_ident #ty_gen>(body, content_type).await?;\n\t\t\t\t\t\t#validate_trait::validate(&res).map_err(|err| ::gotham_formdata::Error::InvalidData(err))?;\n\t\t\t\t\t\tOk(res)\n\t\t\t\t\t}.boxed()\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","derive","src","form_data","validation_error.rs"],"content":"use super::Field;\nuse heck::{CamelCase, SnakeCase};\nuse proc_macro2::{Ident, Span, TokenStream};\nuse syn::{LitStr, Visibility};\n\npub(super) struct ValidationError<'a> {\n\tpub(super) name: &'a Ident,\n\tpub(super) vis: &'a Visibility,\n\tpub(super) ident: Ident,\n\tpub(super) fields: &'a [Field]\n}\n\nimpl<'a> ValidationError<'a> {\n\tpub(super) fn gen_struct(&self) -> TokenStream {\n\t\tlet name = &self.name;\n\t\tlet vis = &self.vis;\n\t\tlet ident = &self.ident;\n\n\t\tlet doc = format!(\n\t\t\t\"This error is returned when form data parsed for [{}] failed validation.\",\n\t\t\tname\n\t\t);\n\n\t\tlet field_names = self\n\t\t\t.fields\n\t\t\t.iter()\n\t\t\t.map(|f| LitStr::new(&f.ident.to_string(), Span::call_site()))\n\t\t\t.collect::<Vec<_>>();\n\t\tlet variant_idents = self\n\t\t\t.fields\n\t\t\t.iter()\n\t\t\t.map(|f| format_ident!(\"{}Invalid\", f.ident.to_string().to_camel_case()))\n\t\t\t.collect::<Vec<_>>();\n\t\tlet invalid_idents = self\n\t\t\t.fields\n\t\t\t.iter()\n\t\t\t.map(|f| format_ident!(\"invalid_{}\", f.ident.to_string().to_snake_case()))\n\t\t\t.collect::<Vec<_>>();\n\t\t// TODO variant_error_types\n\n\t\tquote! {\n\t\t\t#[doc = #doc]\n\t\t\t#[derive(Debug)]\n\t\t\t#vis enum #ident {\n\t\t\t\t#(\n\t\t\t\t\t#variant_idents(String)\n\t\t\t\t),*\n\t\t\t}\n\n\t\t\timpl #ident {\n\t\t\t\t#[doc(hidden)]\n\t\t\t\tfn invalid<Err: ::std::fmt::Display>(field: &str, err: Err) -> Self {\n\t\t\t\t\tmatch field {\n\t\t\t\t\t\t#(\n\t\t\t\t\t\t\t#field_names => Self::#invalid_idents(err),\n\t\t\t\t\t\t)*\n\t\t\t\t\t\t_ => panic!(\"Unknown field {}\", field)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t#(\n\t\t\t\t\tfn #invalid_idents<Err: ::std::fmt::Display>(err: Err) -> Self {\n\t\t\t\t\t\tSelf::#variant_idents(err.to_string())\n\t\t\t\t\t}\n\t\t\t\t)*\n\n\t\t\t\t#vis fn field_name(&self) -> &'static str {\n\t\t\t\t\tmatch self {\n\t\t\t\t\t\t#( Self::#variant_idents(_) => #field_names, )*\n\t\t\t\t\t\t_ => unreachable!()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\timpl ::std::fmt::Display for #ident {\n\t\t\t\tfn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n\t\t\t\t\twrite!(f, \"Invalid value for field {}:\", self.field_name())?;\n\t\t\t\t\tmatch self {\n\t\t\t\t\t\t#( Self::#variant_idents(err) => write!(f, \"{}\", err), )*\n\t\t\t\t\t\t_ => unreachable!()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\timpl ::std::error::Error for #ident {}\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","derive","src","lib.rs"],"content":"//! This crate implements derive macros for the `gotham_formdata` crate.\n#![warn(missing_docs, rust_2018_idioms)]\n#![deny(unreachable_pub)]\n#![forbid(unsafe_code)]\n\n#[macro_use]\nextern crate quote;\n\nuse proc_macro::TokenStream;\nuse proc_macro2::TokenStream as TokenStream2;\nuse syn::{parse_macro_input, DeriveInput, Result};\n\nmod form_data;\nmod util;\n\n#[inline]\nfn print_tokens(tokens: TokenStream2) -> TokenStream {\n\t//eprintln!(\"{}\", tokens);\n\ttokens.into()\n}\n\n#[inline]\nfn expand_derive<F>(input: TokenStream, expand: F) -> TokenStream\nwhere\n\tF: FnOnce(DeriveInput) -> Result<TokenStream2>\n{\n\tprint_tokens(expand(parse_macro_input!(input)).unwrap_or_else(|err| err.to_compile_error()))\n}\n\n/// This derive macro implements `FormData` for the struct it is invoked on. Enums, unions and\n/// tuple structs are not supported.\n#[proc_macro_derive(FormData, attributes(validate))]\npub fn derive_form_data(input: TokenStream) -> TokenStream {\n\texpand_derive(input, form_data::expand)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","derive","src","util.rs"],"content":"use proc_macro2::Span;\nuse syn::{Error, Path};\n\npub(crate) trait CollectToResult {\n\ttype Item;\n\n\tfn collect_to_result(self) -> Result<Vec<Self::Item>, Error>;\n}\n\nimpl<Item, I> CollectToResult for I\nwhere\n\tI: Iterator<Item = Result<Item, Error>>\n{\n\ttype Item = Item;\n\n\tfn collect_to_result(self) -> Result<Vec<Item>, Error> {\n\t\tself.fold(<Result<Vec<Item>, Error>>::Ok(Vec::new()), |res, code| match (code, res) {\n\t\t\t(Ok(code), Ok(mut codes)) => {\n\t\t\t\tcodes.push(code);\n\t\t\t\tOk(codes)\n\t\t\t},\n\t\t\t(Ok(_), Err(errors)) => Err(errors),\n\t\t\t(Err(err), Ok(_)) => Err(err),\n\t\t\t(Err(err), Err(mut errors)) => {\n\t\t\t\terrors.combine(err);\n\t\t\t\tErr(errors)\n\t\t\t}\n\t\t})\n\t}\n}\n\npub(crate) trait PathEndsWith {\n\tfn ends_with(&self, s: &str) -> bool;\n}\n\nimpl PathEndsWith for Path {\n\tfn ends_with(&self, s: &str) -> bool {\n\t\tself.segments.last().map(|segment| segment.ident.to_string()).as_deref() == Some(s)\n\t}\n}\n\npub(crate) trait WithSpan {\n\tfn with_span(self, span: Span) -> Self;\n}\n\nimpl WithSpan for Error {\n\tfn with_span(self, span: Span) -> Self {\n\t\tlet mut err: Option<Self> = None;\n\t\tfor old_err in self {\n\t\t\tlet new_err = Error::new(span, old_err);\n\t\t\terr = match err {\n\t\t\t\tSome(mut err) => {\n\t\t\t\t\terr.combine(new_err);\n\t\t\t\t\tSome(err)\n\t\t\t\t},\n\t\t\t\tNone => Some(new_err)\n\t\t\t};\n\t\t}\n\t\terr.unwrap()\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","conversion.rs"],"content":"/*!\nThis mod contains conversion traits for common used types, that allows them to be created from\na stream of bytes. Furthermore, it allows every type that implements [FromStr] plus some other\ncommon types to be converted.\n\nYou cannot implement any of these traits manually. This is intentional. Instead, if you want to\nprovide a custom conversion method, just implement it as a method for your type:\n\n```rust\nuse futures_util::{FutureExt, StreamExt};\nuse gotham_formdata::{conversion::ConversionFuture, value::{BytesOrString, Value}, FormData};\n\n/// This type parses Base64-encoded values to a [Vec<u8>].\nstruct Base64(Vec<u8>);\n\nimpl Base64 {\n\t// the method signature needs to be roughly equivalent to this\n\tasync fn convert_value<E>(\n\t\t\tname: &str,\n\t\t\tvalue: Value<'_, gotham_formdata::Error<E>>\n\t) -> Result<Self, gotham_formdata::Error<E>>\n\twhere\n\t\tE: std::error::Error\n\t{\n\t\tlet decoded = match value.value {\n\t\t\tBytesOrString::Bytes(mut stream) => {\n\t\t\t\tlet mut buf: Vec<u8> = Vec::new();\n\t\t\t\twhile let Some(data) = stream.next().await {\n\t\t\t\t\tbuf.extend_from_slice(&data?);\n\t\t\t\t}\n\t\t\t\tbase64::decode(&buf)\n\t\t\t},\n\t\t\tBytesOrString::String(string) => base64::decode(string.as_bytes())\n\t\t}.map_err(|err| gotham_formdata::Error::IllegalField(name.to_owned(), err.into()))?;\n\n\t\tOk(Self(decoded))\n\t}\n}\n\n#[derive(FormData)]\nstruct MyData {\n\tfoo: Base64\n}\n# mod base64 { pub fn decode(input: &[u8]) -> Result<Vec<u8>, std::convert::Infallible> { unimplemented!() } }\n```\n*/\n\nuse crate::{\n\tvalue::{BytesOrString, Value},\n\tError\n};\nuse bytes::{Bytes, BytesMut};\nuse futures_util::{future::FutureExt, stream::StreamExt};\nuse gotham::anyhow;\nuse std::{future::Future, pin::Pin, str::FromStr};\n\n/// Re-exports for use in derive macro.\n#[doc(hidden)]\npub mod prelude {\n\tpub use super::{ConvertFromStr, ConvertRawBytes};\n}\n\nmod private {\n\t/// This trait ensures that none of the conversion traits can be implemented manually.\n\tpub trait Sealed1 {}\n\n\t/// This trait ensures that none of the conversion traits can be implemented manually.\n\tpub trait Sealed2 {}\n}\n\n/// The future returned from conversion methods.\npub type ConversionFuture<'a, T, Err> = Pin<Box<dyn Future<Output = Result<T, Err>> + Send + 'a>>;\n\n/// This trait is used to convert types that implement [FromStr] from a stream of bytes.\n///\n/// It is not possible to implement this trait manually. This is intentional. Look at the\n/// [module documentation](self) for an example how to convert custom types.\npub trait ConvertFromStr<Err>: private::Sealed1 + Sized {\n\t/// Perform the conversion.\n\tfn convert_value<'a>(name: &'a str, value: Value<'a, Err>) -> ConversionFuture<'a, Self, Err>;\n}\n\nimpl<T> private::Sealed1 for T\nwhere\n\tT: FromStr,\n\tT::Err: Into<anyhow::Error>\n{\n}\n\nimpl<E, T> ConvertFromStr<Error<E>> for T\nwhere\n\tE: std::error::Error,\n\tT: FromStr,\n\tT::Err: Into<anyhow::Error>\n{\n\tfn convert_value<'a>(name: &'a str, value: Value<'a, Error<E>>) -> ConversionFuture<'a, Self, Error<E>> {\n\t\tasync move {\n\t\t\tlet buf = match value.value {\n\t\t\t\tBytesOrString::Bytes(mut stream) => {\n\t\t\t\t\tlet mut buf = String::new();\n\t\t\t\t\twhile let Some(data) = stream.next().await {\n\t\t\t\t\t\tlet data = data?;\n\t\t\t\t\t\tlet str = String::from_utf8_lossy(data.as_ref());\n\t\t\t\t\t\tbuf.push_str(&str);\n\t\t\t\t\t}\n\t\t\t\t\tbuf.into()\n\t\t\t\t},\n\t\t\t\tBytesOrString::String(buf) => buf\n\t\t\t};\n\n\t\t\tbuf.parse::<Self>()\n\t\t\t\t.map_err(|err| Error::IllegalField(name.to_owned(), err.into()))\n\t\t}\n\t\t.boxed()\n\t}\n}\n\n/// This trait is used to convert `Vec<u8>` and similar types from a stream of bytes.\n///\n/// It is not possible to implement this trait manually. This is intentional. Look at the\n/// [module documentation](self) for an example how to convert custom types.\npub trait ConvertRawBytes<'a, Err>: private::Sealed2 + Sized {\n\t/// Perform the conversion.\n\tfn convert_value(name: &'a str, value: Value<'a, Err>) -> ConversionFuture<'a, Self, Err>;\n}\n\nimpl private::Sealed2 for Vec<u8> {}\n\nimpl<'a, Err: 'a> ConvertRawBytes<'a, Err> for Vec<u8> {\n\tfn convert_value(_name: &'a str, value: Value<'a, Err>) -> ConversionFuture<'a, Self, Err> {\n\t\tasync move {\n\t\t\tmatch value.value {\n\t\t\t\tBytesOrString::Bytes(mut stream) => {\n\t\t\t\t\tlet mut buf: Vec<u8> = Vec::new();\n\t\t\t\t\twhile let Some(data) = stream.next().await {\n\t\t\t\t\t\tbuf.extend_from_slice(&data?);\n\t\t\t\t\t}\n\t\t\t\t\tOk(buf)\n\t\t\t\t},\n\t\t\t\tBytesOrString::String(string) => Ok(string.as_bytes().to_vec())\n\t\t\t}\n\t\t}\n\t\t.boxed()\n\t}\n}\n\nimpl private::Sealed2 for BytesMut {}\n\nimpl<'a, Err: 'a> ConvertRawBytes<'a, Err> for BytesMut {\n\tfn convert_value(_name: &'a str, value: Value<'a, Err>) -> ConversionFuture<'a, Self, Err> {\n\t\tasync move {\n\t\t\tmatch value.value {\n\t\t\t\tBytesOrString::Bytes(mut stream) => {\n\t\t\t\t\tlet mut buf = BytesMut::new();\n\t\t\t\t\twhile let Some(data) = stream.next().await {\n\t\t\t\t\t\tbuf.extend_from_slice(&data?);\n\t\t\t\t\t}\n\t\t\t\t\tOk(buf)\n\t\t\t\t},\n\t\t\t\tBytesOrString::String(string) => Ok(string.as_bytes().into())\n\t\t\t}\n\t\t}\n\t\t.boxed()\n\t}\n}\n\nimpl private::Sealed2 for Bytes {}\n\nimpl<'a, Err: 'a> ConvertRawBytes<'a, Err> for Bytes {\n\tfn convert_value(name: &'a str, value: Value<'a, Err>) -> ConversionFuture<'a, Self, Err> {\n\t\tBytesMut::convert_value(name, value).map(|res| res.map(Into::into)).boxed()\n\t}\n}\n","traces":[{"line":96,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":97,"address":[2998798],"length":1,"stats":{"Line":42},"fn_name":null},{"line":98,"address":[2466948,2466814],"length":1,"stats":{"Line":27},"fn_name":null},{"line":99,"address":[2466960,2466821],"length":1,"stats":{"Line":16},"fn_name":null},{"line":100,"address":[2466982],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":102,"address":[2467416,2467666,2468494],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[2467974,2467640],"length":1,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[2467998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[2468114],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[2466836],"length":1,"stats":{"Line":13},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":112,"address":[2468269,2468928,2468950],"length":1,"stats":{"Line":14},"fn_name":"{{closure}}<urlencoded::LoginDataValidationError,alloc::string::String>"},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":31,"coverable":33},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","error.rs"],"content":"use gotham::anyhow;\nuse mime::Mime;\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\n#[non_exhaustive]\n/// This error type is used when parsing form data from a request body was unsuccessful.\npub enum Error<Err: std::error::Error + 'static> {\n\t/// The body of the request could not be read.\n\t#[error(\"The body of the request could not be read\")]\n\tIllegalBody(#[from] gotham::hyper::Error),\n\t/// The content type of the body was not a valid mime type.\n\t#[error(\"The 'Content-Type' header could not be parsed: {0}\")]\n\tIllegalContentType(#[from] mime::FromStrError),\n\t/// The content type of the body contained unreadable bytes.\n\t#[error(\"The 'Content-Type' header could not be parsed: {0}\")]\n\tIllegalContentTypeValue(#[from] gotham::hyper::header::ToStrError),\n\t/// The value of a field could not be parsed into that field's type.\n\t#[error(\"The field {0} could not be parsed: {1}\")]\n\tIllegalField(String, #[source] anyhow::Error),\n\t/// The body was parsed but contained data that did not pass validation.\n\t#[error(\"The body contained invalid data: {0}\")]\n\tInvalidData(#[source] Err),\n\t/// An I/O error occured while reading the body.\n\t#[error(\"I/O Error while reading body: {0}\")]\n\tIoError(#[from] std::io::Error),\n\t/// The body was a multipart body but did not specify a boundary.\n\t#[error(\"The request failed to specify the multipart boundary\")]\n\tMissingBoundary,\n\t/// The request did not specify a content type.\n\t#[error(\"The request is missing a 'Content-Type' header\")]\n\tMissingContentType,\n\t/// One of the multipart parts is missing a `Content-Disposition` header.\n\t#[error(\"Missing a 'Content-Disposition' header\")]\n\tMissingContentDisposition,\n\t/// The body is missing a required field.\n\t#[error(\"Missing Field '{0}'\")]\n\tMissingField(String),\n\t/// The multipart format was invalid.\n\t#[error(\"Multipart error: {0}\")]\n\tMultipartError(#[from] multer::Error),\n\t/// The body's content type is not supported.\n\t#[error(\"Unknown 'Content-Type' header value: {0}\")]\n\tUnknownContentType(Mime),\n\t/// The body contained a field that was not expected.\n\t#[error(\"Unknown Field '{0}'\")]\n\tUnknownField(String)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","form_data.rs"],"content":"use gotham::state::State;\nuse std::{future::Future, pin::Pin};\n\n/// This is the return type of [FormData::parse_form_data].\n#[allow(type_alias_bounds)]\npub type FormDataFuture<T: FormData> = Pin<Box<dyn Future<Output = Result<T, T::Err>> + Send>>;\n\n/**\nThis is the trait implemented by `#[derive(FormData)]`. It provides a method to parse the struct\nit is implemented for to be parsed from the request body contained in gotham's state.\n\nYou usually don't implement this trait directly, use the derive macro instead.\n*/\npub trait FormData: Sized {\n\t/// The error type returned when parsing the request body was unsuccessful.\n\ttype Err;\n\n\t/// Parse the struct from the request body contained in gotham's state.\n\tfn parse_form_data(state: &mut State) -> FormDataFuture<Self>;\n}\n\n/**\nThis is the equivalent of [FormData] from the state's perspective. Use this if you prefer\n`state.parse_form_data::<MyData>()?` over `MyData::parse_form_data(&mut state)?`.\n*/\npub trait FormDataFromState {\n\t/// Parse `T` from the request body contained in this state.\n\tfn parse_form_data<T: FormData>(&mut self) -> FormDataFuture<T>;\n}\n\nimpl FormDataFromState for State {\n\tfn parse_form_data<T: FormData>(&mut self) -> FormDataFuture<T> {\n\t\tT::parse_form_data(self)\n\t}\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","internal.rs"],"content":"use crate::{\n\tvalidate::Validator,\n\tvalue::{BytesOrString, Value},\n\tError, FormData\n};\nuse futures_util::stream::{StreamExt, TryStreamExt};\nuse gotham::{\n\thyper::{\n\t\tbody::{self, Body},\n\t\theader::{HeaderMap, CONTENT_TYPE}\n\t},\n\tstate::State\n};\nuse mime::{Mime, APPLICATION_WWW_FORM_URLENCODED, BOUNDARY, MULTIPART_FORM_DATA};\nuse multer::Multipart;\nuse std::{borrow::Cow, future::Future, pin::Pin};\n\npub fn assert_validator<V: Validator<T>, T: ?Sized>(_: &V) {}\n\npub type FormDataBuilderFuture<'a, Err> = Pin<Box<dyn Future<Output = Result<(), Error<Err>>> + Send + 'a>>;\n\npub trait FormDataBuilder: Default {\n\ttype Data: FormData;\n\t/// The error that can occur during verification.\n\ttype Err: std::error::Error + 'static;\n\n\tfn add_entry<'a>(\n\t\t&'a mut self,\n\t\tname: Cow<'a, str>,\n\t\tvalue: Value<'a, Error<Self::Err>>\n\t) -> FormDataBuilderFuture<'a, Self::Err>;\n\tfn build(self) -> Result<Self::Data, Error<Self::Err>>;\n}\n\npub fn get_content_type<Err: std::error::Error>(state: &State) -> Result<Mime, Error<Err>> {\n\tlet headers: &HeaderMap = state.borrow();\n\tOk(headers\n\t\t.get(CONTENT_TYPE)\n\t\t.ok_or(Error::MissingContentType)?\n\t\t.to_str()?\n\t\t.parse()?)\n}\n\npub fn get_body(state: &mut State) -> Body {\n\tstate.take()\n}\n\npub async fn parse<T: FormDataBuilder>(body: Body, content_type: Mime) -> Result<T::Data, Error<T::Err>> {\n\tif is_urlencoded(&content_type) {\n\t\tparse_urlencoded::<T>(body).await\n\t} else if is_multipart(&content_type) {\n\t\tparse_multipart::<T>(body, &content_type).await\n\t} else {\n\t\tErr(Error::UnknownContentType(content_type))\n\t}\n}\n\nfn is_urlencoded(content_type: &Mime) -> bool {\n\tcontent_type.essence_str() == APPLICATION_WWW_FORM_URLENCODED.as_ref()\n}\n\nasync fn parse_urlencoded<T: FormDataBuilder>(body: Body) -> Result<T::Data, Error<T::Err>> {\n\tlet body = body::to_bytes(body).await?;\n\n\tlet mut builder = T::default();\n\tfor (name, value) in form_urlencoded::parse(&body) {\n\t\tlet value = Value {\n\t\t\tvalue: BytesOrString::String(value),\n\t\t\tcontent_type: None\n\t\t};\n\t\tbuilder.add_entry(name, value).await?;\n\t}\n\tbuilder.build()\n}\n\nfn is_multipart(content_type: &Mime) -> bool {\n\tcontent_type.essence_str() == MULTIPART_FORM_DATA.as_ref()\n}\n\nasync fn parse_multipart<T: FormDataBuilder>(body: Body, content_type: &Mime) -> Result<T::Data, Error<T::Err>> {\n\tlet boundary = content_type.get_param(BOUNDARY).ok_or(Error::MissingBoundary)?.as_str();\n\tlet mut multipart = Multipart::new(body, boundary);\n\n\tlet mut builder = T::default();\n\twhile let Some(field) = multipart.next_field().await? {\n\t\tlet name = field.name().ok_or(Error::MissingContentDisposition)?.to_owned();\n\t\tlet mime = field.content_type().cloned();\n\n\t\tlet stream = field.map_err(Into::into).boxed();\n\t\tlet value = Value {\n\t\t\tvalue: BytesOrString::Bytes(stream),\n\t\t\tcontent_type: mime\n\t\t};\n\t\tbuilder.add_entry(name.into(), value).await?;\n\t}\n\tbuilder.build()\n}\n","traces":[{"line":18,"address":[1784768,1784773,1784789,1784784,1784800,1784805],"length":1,"stats":{"Line":6},"fn_name":"assert_validator<closure-0,u8>"},{"line":35,"address":[2145792],"length":1,"stats":{"Line":17},"fn_name":"get_content_type<urlencoded::LoginDataValidationError>"},{"line":36,"address":[2145830],"length":1,"stats":{"Line":17},"fn_name":null},{"line":37,"address":[2146096,2145854,2145920,2145979,2146235,2146292,2146451,2146167,2146383],"length":1,"stats":{"Line":85},"fn_name":null},{"line":39,"address":[2145962,2145908,2146014],"length":1,"stats":{"Line":34},"fn_name":null},{"line":40,"address":[2146144,2146217],"length":1,"stats":{"Line":17},"fn_name":null},{"line":41,"address":[2146385,2146275],"length":1,"stats":{"Line":17},"fn_name":null},{"line":44,"address":[3850480],"length":1,"stats":{"Line":6},"fn_name":"get_body"},{"line":45,"address":[3850497],"length":1,"stats":{"Line":6},"fn_name":null},{"line":48,"address":[2149771,2151155,2151294,2149653,2151456,2149632,2149728],"length":1,"stats":{"Line":85},"fn_name":"parse<urlencoded::_IMPL_FORMDATA_FOR_LoginData::LoginDataFormDataBuilder>"},{"line":49,"address":[2149955],"length":1,"stats":{"Line":17},"fn_name":null},{"line":50,"address":[2149987,2151425,2151277,2150158,2150093],"length":1,"stats":{"Line":48},"fn_name":null},{"line":51,"address":[2150061,2150725,2150517],"length":1,"stats":{"Line":10},"fn_name":null},{"line":52,"address":[2948271],"length":1,"stats":{"Line":15},"fn_name":null},{"line":54,"address":[2150609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[3850528],"length":1,"stats":{"Line":6},"fn_name":"is_urlencoded"},{"line":59,"address":[3850537],"length":1,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[2146496,2149344,2149289,2146612,2146512,2146560],"length":1,"stats":{"Line":64},"fn_name":"parse_urlencoded<urlencoded::_IMPL_FORMDATA_FOR_LoginData::LoginDataFormDataBuilder>"},{"line":63,"address":[2951671],"length":1,"stats":{"Line":32},"fn_name":null},{"line":65,"address":[2147192],"length":1,"stats":{"Line":23},"fn_name":null},{"line":66,"address":[2147272,2148663,2147541],"length":1,"stats":{"Line":32},"fn_name":null},{"line":68,"address":[2147815],"length":1,"stats":{"Line":16},"fn_name":null},{"line":71,"address":[2148047,2148668,2148239,2149331,2149075],"length":1,"stats":{"Line":32},"fn_name":null},{"line":73,"address":[2147475],"length":1,"stats":{"Line":16},"fn_name":null},{"line":76,"address":[3850624],"length":1,"stats":{"Line":2},"fn_name":"is_multipart"},{"line":77,"address":[3850633],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[2141005,2141133,2145327,2144701,2145094,2141072,2144611,2145243,2145304,2140976,2144954],"length":1,"stats":{"Line":25},"fn_name":"parse_multipart<urlencoded::_IMPL_FORMDATA_FOR_LoginData::LoginDataFormDataBuilder>"},{"line":81,"address":[2141268,2141817,2144942],"length":1,"stats":{"Line":10},"fn_name":null},{"line":82,"address":[2141833],"length":1,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[2141950],"length":1,"stats":{"Line":5},"fn_name":null},{"line":85,"address":[2141969,2145270,2144285,2145322,2142113,2142667],"length":1,"stats":{"Line":20},"fn_name":null},{"line":86,"address":[2144871,2143156,2142709],"length":1,"stats":{"Line":10},"fn_name":null},{"line":87,"address":[2143160],"length":1,"stats":{"Line":5},"fn_name":null},{"line":89,"address":[2143218],"length":1,"stats":{"Line":5},"fn_name":null},{"line":91,"address":[2143341],"length":1,"stats":{"Line":5},"fn_name":null},{"line":94,"address":[2143855,2144777,2143617,2144290,2145291],"length":1,"stats":{"Line":10},"fn_name":null},{"line":96,"address":[2145003],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":36,"coverable":37},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","lib.rs"],"content":"/*!\nThis crate is an extension to the popular [gotham web framework][gotham] for Rust. It aims to\nreduce boilerplate necessary to read request bodies today as a stop-gap until gotham finally\nimplements a [body extractor].\n\n# :sparkles: Features\n\n- Parse `application/x-www-form-urlencoded` request bodies\n- Parse `multipart/form-data` request bodies\n- Verify the parsed request body\n- `#![forbid(unsafe_code)]` ensures that all functionality is implemented in 100% safe Rust code\n\n# :warning: Warning\n\nThis crate is asynchronous, but does not yet enforce uploads limits. **YOU ARE RESPONSIBLE\nFOR ENFORCING UPLOAD LIMITS.**\n\n# :spiral_notepad: Example\n\n```rust\n# use gotham::handler::HandlerError;\n# use gotham::helpers::http::response::*;\n# use gotham::hyper::{Body, Response, StatusCode};\n# use gotham::state::State;\n# use mime::TEXT_PLAIN;\nuse gotham_formdata::FormData;\n\n#[derive(FormData)]\nstruct LoginData {\n\t#[validate(regex = \"[a-zA-Z0-9_]\", error = \"The username contains illegal characters.\")]\n\tusername: String,\n\t#[validate(min_length = 6)]\n\tpassword: String\n}\n\nasync fn login_handler(state: &mut State) -> Result<Response<Body>, HandlerError> {\n\tlet login_data: LoginData = FormData::parse_form_data(state).await?;\n\tOk(if login_data.password == \"secret\" {\n\t\tcreate_response(state, StatusCode::OK, TEXT_PLAIN, login_data.username)\n\t} else {\n\t\tcreate_empty_response(state, StatusCode::FORBIDDEN)\n\t})\n}\n```\n\n# :label: Versioning\n\nLike all rust crates, this crate will follow semantic versioning guidelines. However, changing\nthe MSRV (minimum supported rust version) is not considered a breaking change.\n\n# :page_with_curl: License\n\n```text\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n\thttps://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```\n\n [body extractor]: https://github.com/gotham-rs/gotham/issues/11\n [gotham]: https://github.com/gotham-rs/gotham\n [multipart]: https://crates.io/crates/multipart\n*/\n\n#![warn(missing_docs, rust_2018_idioms)]\n#![deny(missing_debug_implementations, unreachable_pub)]\n#![forbid(unsafe_code)]\n\n#[doc(hidden)]\n/// Not public API.\npub mod export {\n\tpub use futures_util::{future::FutureExt, stream::StreamExt};\n\tpub use gotham::{hyper::body::Bytes, state::State};\n\n\t#[cfg(feature = \"regex-validation\")]\n\tpub use once_cell::sync::Lazy;\n\t#[cfg(feature = \"regex-validation\")]\n\tpub use regex::Regex;\n}\n\n#[doc(inline)]\npub use gotham_formdata_derive::*;\n\npub mod conversion;\n\nmod error;\npub use error::*;\n\nmod form_data;\npub use form_data::*;\n\n#[doc(hidden)]\n/// Not public API.\npub mod internal;\n\npub mod validate;\n\npub mod value;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","validate","expected.rs"],"content":"use super::Validator;\nuse thiserror::Error;\n\n/// This error is emitted by the [ExpectedValidator] if an unexpected value was found.\n#[derive(Debug, Clone, Copy, Error)]\n#[error(\"Value is not in list of expected values.\")]\npub struct UnexpectedValueError;\n\n/// A validator that checks that a value is in a list of accepted values.\n#[derive(Clone, Copy, Debug)]\npub struct ExpectedValidator<'a, T> {\n\texpected: &'a [T]\n}\n\nimpl<'a, T> ExpectedValidator<'a, T> {\n\t/// Create a new [ExpectedValidator].\n\tpub fn new(expected: &'a [T]) -> Self {\n\t\tSelf { expected }\n\t}\n}\n\nimpl<'a, D, T> Validator<D> for ExpectedValidator<'a, T>\nwhere\n\tD: PartialEq<T>\n{\n\ttype Err = UnexpectedValueError;\n\n\tfn validate(self, data: &D) -> Result<(), Self::Err> {\n\t\tif !self.expected.iter().any(|expected| data == expected) {\n\t\t\treturn Err(UnexpectedValueError);\n\t\t}\n\t\tOk(())\n\t}\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":5,"coverable":5},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","validate","length.rs"],"content":"use super::Validator;\nuse thiserror::Error;\n\n/// This error is emitted by the [MinLengthValidator] if the value was too short.\n#[derive(Clone, Copy, Debug, Error)]\n#[error(\"Value is shorter than minimum length of {0}\")]\npub struct ValueTooShortError(usize);\n\n/// A validator that checks that a string has a minimum length.\n#[derive(Clone, Copy, Debug)]\npub struct MinLengthValidator {\n\tmin_length: usize\n}\n\nimpl MinLengthValidator {\n\t/// Create a new [MinLengthValidator].\n\tpub fn new(min_length: usize) -> Self {\n\t\tSelf { min_length }\n\t}\n}\n\nimpl<T: AsRef<str>> Validator<T> for MinLengthValidator {\n\ttype Err = ValueTooShortError;\n\n\tfn validate(self, data: &T) -> Result<(), Self::Err> {\n\t\tif data.as_ref().len() < self.min_length {\n\t\t\treturn Err(ValueTooShortError(self.min_length));\n\t\t}\n\t\tOk(())\n\t}\n}\n\n/// This error is emitted by the [MaxLengthValidator] if the value was too long.\n#[derive(Clone, Copy, Debug, Error)]\n#[error(\"Value is longer than maximum length of {0}\")]\npub struct ValueTooLongError(usize);\n\n/// A validator that checks that a string has a maximum length.\n#[derive(Clone, Copy, Debug)]\npub struct MaxLengthValidator {\n\tmax_length: usize\n}\n\nimpl MaxLengthValidator {\n\t/// Create a new [MaxLengthValidator].\n\tpub fn new(max_length: usize) -> Self {\n\t\tSelf { max_length }\n\t}\n}\n\nimpl<T: AsRef<str>> Validator<T> for MaxLengthValidator {\n\ttype Err = ValueTooLongError;\n\n\tfn validate(self, data: &T) -> Result<(), Self::Err> {\n\t\tif data.as_ref().len() > self.max_length {\n\t\t\treturn Err(ValueTooLongError(self.max_length));\n\t\t}\n\t\tOk(())\n\t}\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[2006769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","validate","mod.rs"],"content":"//! This mod contains the [Validator] trait as well as pre-defined validation methods.\n\nmod expected;\npub use expected::*;\n\nmod length;\npub use length::*;\n\nmod range;\npub use range::*;\n\nmod validator;\npub use validator::*;\n\n#[cfg(feature = \"regex-validation\")]\nmod regex;\n#[cfg(feature = \"regex-validation\")]\npub use self::regex::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","validate","range.rs"],"content":"use super::Validator;\nuse std::fmt::{Debug, Display};\nuse thiserror::Error;\n\n/// This error is emitted by the [MinValidator] if the value was too small.\n#[derive(Clone, Copy, Debug, Error)]\n#[error(\"Value is smaller than minimum of {0}\")]\npub struct ValueTooSmallError<I: Debug + Display>(I);\n\n/// A validator that checks that an integer is at least of a minimal value.\n#[derive(Clone, Copy, Debug)]\npub struct MinValidator<I> {\n\tmin: I\n}\n\nimpl<I> MinValidator<I> {\n\t/// Create a new [MinValidator].\n\tpub fn new(min: I) -> Self {\n\t\tSelf { min }\n\t}\n}\n\nimpl<I, T> Validator<T> for MinValidator<I>\nwhere\n\tI: Debug + Display + PartialOrd,\n\tT: Clone + Into<I>\n{\n\ttype Err = ValueTooSmallError<I>;\n\n\tfn validate(self, data: &T) -> Result<(), Self::Err> {\n\t\tif data.clone().into() < self.min {\n\t\t\treturn Err(ValueTooSmallError(self.min));\n\t\t}\n\t\tOk(())\n\t}\n}\n\n/// This error is emitted by the [MaxValidator] if the value was too large.\n#[derive(Clone, Copy, Debug, Error)]\n#[error(\"Value is greater than minimum of {0}\")]\npub struct ValueTooLargeError<I: Debug + Display>(I);\n\n/// A validator that checks that an integer is at most of a maximal value.\n#[derive(Clone, Copy, Debug)]\npub struct MaxValidator<I> {\n\tmax: I\n}\n\nimpl<I> MaxValidator<I> {\n\t/// Create a new [MaxValidator].\n\tpub fn new(max: I) -> Self {\n\t\tSelf { max }\n\t}\n}\n\nimpl<I, T> Validator<T> for MaxValidator<I>\nwhere\n\tI: Debug + Display + PartialOrd,\n\tT: Clone + Into<I>\n{\n\ttype Err = ValueTooLargeError<I>;\n\n\tfn validate(self, data: &T) -> Result<(), Self::Err> {\n\t\tif data.clone().into() > self.max {\n\t\t\treturn Err(ValueTooLargeError(self.max));\n\t\t}\n\t\tOk(())\n\t}\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","validate","regex.rs"],"content":"use super::Validator;\nuse regex::Regex;\nuse thiserror::Error;\n\n/// This error is emitted by the [RegexValidator] if the value did not match the regex.\n#[derive(Clone, Copy, Debug, Error)]\n#[error(\"Value is smaller than minimum of {0}\")]\npub struct RegexMismatchError<'re>(&'re Regex);\n\n/// A validator that checks that an integer is at least of a minimal value.\n#[derive(Clone, Debug)]\npub struct RegexValidator<'re> {\n\tre: &'re Regex\n}\n\nimpl<'re> RegexValidator<'re> {\n\t/// Create a new [RegexValidator].\n\tpub fn new(re: &'re Regex) -> Self {\n\t\tSelf { re }\n\t}\n}\n\nimpl<'re, T: AsRef<str>> Validator<T> for RegexValidator<'re> {\n\ttype Err = RegexMismatchError<'re>;\n\n\tfn validate(self, data: &T) -> Result<(), Self::Err> {\n\t\tif !self.re.is_match(data.as_ref()) {\n\t\t\treturn Err(RegexMismatchError(&self.re));\n\t\t}\n\t\tOk(())\n\t}\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":5,"coverable":5},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","validate","validator.rs"],"content":"use either::Either;\nuse std::{convert::Infallible, marker::PhantomData};\n\n/**\nThis trait allows data of type `T` to be verified against custom criteria.\n\nExample:\n\n```rust\nuse gotham_formdata::FormData;\n\nfn validate_password(password: &String) -> Result<(), &'static str> {\n\tif password.len() < 8 {\n\t\treturn Err(\"Password is too short\");\n\t\t}\n\tOk(())\n}\n\n#[derive(FormData)]\nstruct LoginData {\n\tusername: String,\n\t#[validate(validator = validate_password)]\n\tpassword: String\n}\n```\n*/\npub trait Validator<T: ?Sized> {\n\t/// The error returned when validation failed.\n\ttype Err;\n\n\t/// Performs the validation.\n\tfn validate(self, data: &T) -> Result<(), Self::Err>;\n}\n\n/// Convert `()` into an allways accepting validator.\nimpl<T: ?Sized> Validator<T> for () {\n\ttype Err = Infallible;\n\n\tfn validate(self, _: &T) -> Result<(), Infallible> {\n\t\tOk(())\n\t}\n}\n\n/// Convert any function with the correct signature into a validator.\nimpl<F, Err, T: ?Sized> Validator<T> for F\nwhere\n\tF: Fn(&T) -> Result<(), Err>\n{\n\ttype Err = Err;\n\n\tfn validate(self, data: &T) -> Result<(), Err> {\n\t\tself(data)\n\t}\n}\n\n/// This struct combines two validators and only validates its input if both validators pass it.\n#[derive(Debug, Clone)]\npub struct CombinedValidator<T: ?Sized, V: Validator<T>, W: Validator<T>>(V, W, PhantomData<T>);\n\nimpl<T: ?Sized, V: Validator<T>, W: Validator<T>> CombinedValidator<T, V, W> {\n\t/// Construct a new [CombinedValidator] from two other validators.\n\tpub fn new(first_validator: V, second_validator: W) -> Self {\n\t\tSelf(first_validator, second_validator, Default::default())\n\t}\n}\n\nimpl<T: ?Sized, V: Validator<T>, W: Validator<T>> Validator<T> for CombinedValidator<T, V, W> {\n\ttype Err = Either<V::Err, W::Err>;\n\n\tfn validate(self, data: &T) -> Result<(), Self::Err> {\n\t\tself.0.validate(data).map_err(Either::Left)?;\n\t\tself.1.validate(data).map_err(Either::Right)\n\t}\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":7,"coverable":9},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","value.rs"],"content":"/*!\nThis mod defines the [Value] used for parsing the form data.\n*/\n\nuse bytes::Bytes;\nuse futures_util::stream::Stream;\nuse std::{\n\tborrow::Cow,\n\tfmt::{self, Debug},\n\tpin::Pin\n};\n\npub use mime::Mime;\n\n/// A stream of bytes.\npub type ByteStream<Err> = Pin<Box<dyn Stream<Item = Result<Bytes, Err>> + Send>>;\n\n/// Either a stream of bytes or a string.\npub enum BytesOrString<'a, Err> {\n\t/// Byte stream.\n\tBytes(ByteStream<Err>),\n\t/// String.\n\tString(Cow<'a, str>)\n}\n\nimpl<'a, Err> Debug for BytesOrString<'a, Err> {\n\tfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\t\tmatch self {\n\t\t\tSelf::Bytes(_) => write!(f, \"BytesOrString::Bytes(...)\"),\n\t\t\tSelf::String(_) => write!(f, \"BytesOrString::String(...)\")\n\t\t}\n\t}\n}\n\n/// A value, either a string parsed from and urlencoded form, or bytes from a multipart body.\n#[derive(Debug)]\npub struct Value<'a, Err> {\n\t/// The value of the field.\n\tpub value: BytesOrString<'a, Err>,\n\t/// The content-type of the field, if any.\n\tpub content_type: Option<Mime>\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","multipart.rs"],"content":"use gotham::{\n\thandler::HandlerError,\n\thelpers::http::response::*,\n\thyper::{Body, Response, StatusCode},\n\trouter::builder::*,\n\tstate::State,\n\ttest::TestServer\n};\nuse gotham_formdata::FormData;\nuse mime::{Mime, TEXT_PLAIN};\n\n#[derive(FormData)]\nstruct LoginData {\n\tusername: String,\n\tpassword: String\n}\n\nasync fn login_handler(state: &mut State) -> Result<Response<Body>, HandlerError> {\n\tlet login_data: LoginData = FormData::parse_form_data(state).await?;\n\tOk(if login_data.password == \"secret\" {\n\t\tcreate_response(state, StatusCode::OK, TEXT_PLAIN, login_data.username)\n\t} else {\n\t\tcreate_empty_response(state, StatusCode::FORBIDDEN)\n\t})\n}\n\n#[test]\nfn multipart() {\n\tlet _ = pretty_env_logger::try_init_timed();\n\n\tlet server = TestServer::new(build_simple_router(|router| {\n\t\trouter.post(\"/login\").to_async_borrowing(login_handler);\n\t}))\n\t.unwrap();\n\n\tlet mime: Mime = \"multipart/form-data; boundary=GOTHAMMULTIPART\".parse().unwrap();\n\tlet body = \"--GOTHAMMULTIPART\\r\\nContent-Disposition: form-data; name=\\\"username\\\"\\r\\n\\r\\ntestuser\\r\\n--GOTHAMMULTIPART\\r\\nContent-Disposition: form-data; name=\\\"password\\\"\\r\\n\\r\\nsecret\\r\\n--GOTHAMMULTIPART--\\r\\n\";\n\tlet res = server.client().post(\"http://localhost/login\", body, mime).perform().unwrap();\n\tlet body = res.read_body().unwrap();\n\tassert_eq!(&body, b\"testuser\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","trybuild_ui.rs"],"content":"use trybuild::TestCases;\n\n#[test]\nfn trybuild_ui() {\n\tlet t = TestCases::new();\n\tt.compile_fail(\"tests/ui/*.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","types.rs"],"content":"use futures_executor::block_on;\nuse gotham::{\n\thyper::{\n\t\tbody::{Body, Bytes},\n\t\theader::{HeaderMap, CONTENT_TYPE}\n\t},\n\tstate::State\n};\nuse gotham_formdata::FormData;\nuse mime::{Mime, APPLICATION_WWW_FORM_URLENCODED};\nuse percent_encoding::{percent_encode, NON_ALPHANUMERIC};\nuse std::{convert::Infallible, str::FromStr};\n\nfn with_body(body: &[u8], content_type: Mime, callback: impl Fn(&mut State)) {\n\tState::with_new(|state| {\n\t\tlet body: Body = body.to_owned().into();\n\t\tstate.put(body);\n\n\t\tlet mut headers = HeaderMap::new();\n\t\theaders.insert(CONTENT_TYPE, content_type.to_string().parse().unwrap());\n\t\tstate.put(headers);\n\n\t\tcallback(state);\n\t});\n}\n\nfn with_body_foo(foo: &[u8], callback: impl Fn(&mut State)) {\n\tlet urlencoded = format!(\"foo={}\", percent_encode(foo, NON_ALPHANUMERIC));\n\twith_body(urlencoded.as_bytes(), APPLICATION_WWW_FORM_URLENCODED, &callback);\n\n\tlet mut multipart = Vec::new();\n\tmultipart.extend_from_slice(b\"--GOTHAM-MULTIPART-BOUNDARY\\r\\nContent-Disposition: form-data; name=\\\"foo\\\"\\r\\n\\r\\n\");\n\tmultipart.extend_from_slice(foo);\n\tmultipart.extend_from_slice(b\"\\r\\n--GOTHAM-MULTIPART-BOUNDARY--\");\n\tlet mime = \"multipart/form-data; boundary=GOTHAM-MULTIPART-BOUNDARY\";\n\twith_body(&multipart, mime.parse().unwrap(), &callback);\n}\n\n#[test]\nfn test_custom_from_str_and_convert() {\n\tuse gotham_formdata::value::Value;\n\n\t#[derive(Debug)]\n\tstruct CustomType(bool);\n\n\timpl FromStr for CustomType {\n\t\ttype Err = Infallible;\n\n\t\tfn from_str(_: &str) -> Result<Self, Infallible> {\n\t\t\tOk(Self(false))\n\t\t}\n\t}\n\n\timpl CustomType {\n\t\tasync fn convert_value<E>(_name: &str, _value: Value<'_, E>) -> Result<Self, E> {\n\t\t\tOk(Self(true))\n\t\t}\n\t}\n\n\t#[derive(Debug, FormData)]\n\tstruct Data {\n\t\tfoo: CustomType\n\t}\n\n\twith_body_foo(b\"\", |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert!(data.foo.0);\n\t})\n}\n\n#[test]\nfn test_string() {\n\t#[derive(Debug, FormData, PartialEq)]\n\tstruct Data {\n\t\tfoo: String\n\t}\n\n\twith_body_foo(\n\t\tb\"\\xF0\\x9F\\x9A\\xA2 DONAUDAMPFSCHIFFFAHRTSKAPIT\\xC3\\x84NSM\\xC3\\x9CTZE \\xF0\\x9F\\x91\\xAE\",\n\t\t|state| {\n\t\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\t\tassert_eq!(data, Data {\n\t\t\t\tfoo: \"🚢 DONAUDAMPFSCHIFFFAHRTSKAPITÄNSMÜTZE 👮\".to_owned()\n\t\t\t});\n\t\t}\n\t);\n}\n\n#[test]\nfn test_vec_u8() {\n\t#[derive(Debug, FormData, PartialEq)]\n\tstruct Data {\n\t\tfoo: Vec<u8>\n\t}\n\n\twith_body_foo(\n\t\tb\"\\xF0\\x9F\\x9A\\xA2 DONAUDAMPFSCHIFFFAHRTSKAPIT\\xC3\\x84NSM\\xC3\\x9CTZE \\xF0\\x9F\\x91\\xAE\",\n\t\t|state| {\n\t\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\t\tassert_eq!(data, Data {\n\t\t\t\tfoo: \"🚢 DONAUDAMPFSCHIFFFAHRTSKAPITÄNSMÜTZE 👮\".as_bytes().to_owned()\n\t\t\t});\n\t\t}\n\t);\n}\n\n#[test]\nfn test_bytes() {\n\t#[derive(Debug, FormData, PartialEq)]\n\tstruct Data {\n\t\tfoo: Bytes\n\t}\n\n\twith_body_foo(\n\t\tb\"\\xF0\\x9F\\x9A\\xA2 DONAUDAMPFSCHIFFFAHRTSKAPIT\\xC3\\x84NSM\\xC3\\x9CTZE \\xF0\\x9F\\x91\\xAE\",\n\t\t|state| {\n\t\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\t\tassert_eq!(data, Data {\n\t\t\t\tfoo: \"🚢 DONAUDAMPFSCHIFFFAHRTSKAPITÄNSMÜTZE 👮\".as_bytes().into()\n\t\t\t});\n\t\t}\n\t);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","convert_from_str_sealed.rs"],"content":"use futures_util::FutureExt;\nuse gotham_formdata::{\n\tconversion::{ConvertFromStr, ConversionFuture},\n\tvalue::Value\n};\n\nstruct MyType;\n\nimpl<E> ConvertFromStr<E> for MyType {\n\tfn convert_value<'a>(name: &'a str, value: Value<'a, E>) -> ConversionFuture<'a, Self, E> {\n\t\tasync move {\n\t\t\tOk(MyType)\n\t\t}.boxed()\n\t}\n}\n\nfn main() {\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","convert_raw_bytes_sealed.rs"],"content":"use futures_util::FutureExt;\nuse gotham_formdata::{\n\tconversion::{ConvertRawBytes, ConversionFuture},\n\tvalue::Value\n};\n\nstruct MyType;\n\nimpl<'a, E: 'a> ConvertRawBytes<'a, E> for MyType {\n\tfn convert_value(_name: &'a str, _value: Value<'a, E>) -> ConversionFuture<'a, Self, E> {\n\t\tasync move {\n\t\t\tOk(MyType)\n\t\t}.boxed()\n\t}\n}\n\nfn main() {\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","form_data_enum.rs"],"content":"use gotham_formdata::FormData;\n\n#[derive(FormData)]\nenum MyFormData {\n}\n\nfn main() {\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","form_data_tuple_struct.rs"],"content":"use gotham_formdata::FormData;\n\n#[derive(FormData)]\nstruct MyFormData(String);\n\nfn main() {\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","form_data_union.rs"],"content":"use gotham_formdata::FormData;\n\n#[derive(FormData)]\nunion MyFormData {\n\tfoo: u8,\n\tbar: i8\n}\n\nfn main() {\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","form_data_unparsable.rs"],"content":"use gotham_formdata::FormData;\n\nstruct MyType;\n\n#[derive(FormData)]\nstruct MyFormData {\n\tfoo: MyType\n}\n\nfn main() {\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","validate_custom_nonsense.rs"],"content":"use gotham_formdata::FormData;\n\n#[derive(FormData)]\nstruct MyFormData {\n\t#[validate(validator = struct CustomValidator)]\n\tvalue: u8\n}\n\nfn main() {\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","validate_custom_str.rs"],"content":"use gotham_formdata::FormData;\n\n#[derive(FormData)]\nstruct MyFormData {\n\t#[validate(validator = \"foobar\")]\n\tvalue: u8\n}\n\nfn main() {\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","validate_min_length_i32.rs"],"content":"use gotham_formdata::FormData;\n\n#[derive(FormData)]\nstruct MyFormData {\n\t#[validate(min_length = -1 as i32)]\n\tvalue: String\n}\n\nfn main() {\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","validate_min_length_on_u8.rs"],"content":"use gotham_formdata::FormData;\n\n#[derive(FormData)]\nstruct MyFormData {\n\t#[validate(min_length = 42)]\n\tvalue: u8\n}\n\nfn main() {\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","validate_min_length_str.rs"],"content":"use gotham_formdata::FormData;\n\n#[derive(FormData)]\nstruct MyFormData {\n\t#[validate(min_length = \"foobar\")]\n\tvalue: String\n}\n\nfn main() {\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","validate_min_outofbounds.rs"],"content":"use gotham_formdata::FormData;\n\n#[derive(FormData)]\nstruct MyFormData {\n\t#[validate(min = 12345)]\n\tvalue: u8\n}\n\nfn main() {\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","validate_multiple_errors.rs"],"content":"use gotham_formdata::FormData;\n\n#[derive(FormData)]\nstruct MyFormData {\n\t#[validate(min = 1, error = \"Minimum value is 1\", error = \"The value must be at least 1\")]\n\tvalue: u8\n}\n\nfn main() {\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","validate_no_args.rs"],"content":"use gotham_formdata::FormData;\n\n#[derive(FormData)]\nstruct MyFormData {\n\t#[validate]\n\tvalue: u8\n}\n\nfn main() {\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","validate_no_list.rs"],"content":"use gotham_formdata::FormData;\n\n#[derive(FormData)]\nstruct MyFormData {\n\t#[validate = \"custom_validator\"]\n\tvalue: u8\n}\n\nfn main() {\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","validate_unknown_key.rs"],"content":"use gotham_formdata::FormData;\n\n#[derive(FormData)]\nstruct MyFormData {\n\t#[validate(foo = \"bar\")]\n\tvalue: u8\n}\n\nfn main() {\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","urlencoded.rs"],"content":"use gotham::{\n\thandler::HandlerError,\n\thelpers::http::response::*,\n\thyper::{Body, Response, StatusCode},\n\trouter::builder::*,\n\tstate::State,\n\ttest::TestServer\n};\nuse gotham_formdata::FormData;\nuse mime::{Mime, TEXT_PLAIN};\n\n#[derive(FormData)]\nstruct LoginData {\n\tusername: String,\n\tpassword: String\n}\n\nasync fn login_handler(state: &mut State) -> Result<Response<Body>, HandlerError> {\n\tlet login_data: LoginData = FormData::parse_form_data(state).await?;\n\tOk(if login_data.password == \"secret\" {\n\t\tcreate_response(state, StatusCode::OK, TEXT_PLAIN, login_data.username)\n\t} else {\n\t\tcreate_empty_response(state, StatusCode::FORBIDDEN)\n\t})\n}\n\n#[test]\nfn urlencoded() {\n\tlet _ = pretty_env_logger::try_init_timed();\n\n\tlet server = TestServer::new(build_simple_router(|router| {\n\t\trouter.post(\"/login\").to_async_borrowing(login_handler);\n\t}))\n\t.unwrap();\n\n\tlet mime: Mime = \"application/x-www-form-urlencoded\".parse().unwrap();\n\tlet body = \"username=testuser&password=secret\";\n\tlet res = server.client().post(\"http://localhost/login\", body, mime).perform().unwrap();\n\tlet body = res.read_body().unwrap();\n\tassert_eq!(&body, b\"testuser\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","validation.rs"],"content":"use futures_executor::block_on;\nuse gotham::{\n\thyper::{\n\t\theader::{HeaderMap, CONTENT_TYPE},\n\t\tBody\n\t},\n\tstate::State\n};\nuse gotham_formdata::{Error, FormData};\nuse mime::{Mime, APPLICATION_WWW_FORM_URLENCODED};\nuse std::convert::Infallible;\n\nfn custom_validator(value: &u8) -> Result<(), &'static str> {\n\tif *value >= 128 {\n\t\treturn Err(\"Value out of range\");\n\t}\n\tOk(())\n}\n\nfn with_body(body: &'static [u8], content_type: Mime, callback: impl Fn(&mut State)) {\n\tState::with_new(|state| {\n\t\tlet body: Body = body.into();\n\t\tstate.put(body);\n\n\t\tlet mut headers = HeaderMap::new();\n\t\theaders.insert(CONTENT_TYPE, content_type.to_string().parse().unwrap());\n\t\tstate.put(headers);\n\n\t\tcallback(state);\n\t});\n}\n\n#[test]\nfn validate_custom_error() {\n\t#[derive(Debug, FormData, PartialEq)]\n\tstruct Data {\n\t\t#[validate(min = 1, error = \"Too small.\")]\n\t\tdata: u8\n\t}\n\n\t// testing that we can define `.validate()` eventhough that name is also used in the derive code\n\timpl Data {\n\t\tfn validate(&self) -> bool {\n\t\t\ttrue\n\t\t}\n\t}\n\n\twith_body(b\"data=1\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert!(data.validate()); // NOTE this is defined above, not generated\n\t\tassert_eq!(data, Data { data: 1 })\n\t});\n\n\twith_body(b\"data=0\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap_err();\n\t\tmatch data {\n\t\t\tError::InvalidData(DataValidationError::DataInvalid(err)) => assert_eq!(err, \"Too small.\"),\n\t\t\t_ => panic!(\"Expected DataVerificationError::DataInvalid, got {:?}\", data)\n\t\t};\n\t});\n}\n\n#[test]\nfn validate_combined_validator() {\n\t#[derive(Debug, FormData, PartialEq)]\n\tstruct Data {\n\t\t#[validate(min = 1, max = 2)]\n\t\tdata: u8\n\t}\n\n\twith_body(b\"data=1\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data { data: 1 })\n\t});\n\n\twith_body(b\"data=2\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data { data: 2 })\n\t});\n\n\twith_body(b\"data=0\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap_err();\n\t\tassert!(matches!(data, Error::InvalidData(_)));\n\t});\n\n\twith_body(b\"data=3\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap_err();\n\t\tassert!(matches!(data, Error::InvalidData(_)));\n\t});\n}\n\n#[test]\nfn validate_custom_validator() {\n\t#[derive(Debug, FormData, PartialEq)]\n\tstruct Data {\n\t\t#[validate(validator = custom_validator)]\n\t\tdata: u8\n\t}\n\n\twith_body(b\"data=1\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data { data: 1 })\n\t});\n\n\twith_body(b\"data=128\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap_err();\n\t\tassert!(matches!(data, Error::InvalidData(_)));\n\t});\n}\n\n#[test]\nfn validate_custom_validator_lambda() {\n\t#[derive(Debug, FormData, PartialEq)]\n\tstruct Data {\n\t\t#[validate(validator = |value: &u8| {\n\t\t\tif *value == 0 {\n\t\t\t\treturn Err(\"Value must not be 0\");\n\t\t\t}\n\t\t\tOk(())\n\t\t})]\n\t\tdata: u8\n\t}\n\n\twith_body(b\"data=1\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data { data: 1 })\n\t});\n\n\twith_body(b\"data=0\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap_err();\n\t\tassert!(matches!(data, Error::InvalidData(_)));\n\t});\n}\n\n#[test]\nfn validate_custom_validator_string_str() {\n\t#[derive(Debug, FormData, PartialEq)]\n\tstruct Data {\n\t\t#[validate(validator = |_: &str| Result::<(), Infallible>::Ok(()))]\n\t\tdata: String\n\t}\n\n\twith_body(b\"data=foo\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data { data: \"foo\".to_owned() })\n\t});\n}\n\n#[test]\nfn validate_min_length() {\n\t#[derive(Debug, FormData, PartialEq)]\n\tstruct Data {\n\t\t#[validate(min_length = 8)]\n\t\tdata: String\n\t}\n\n\twith_body(b\"data=verylong\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data {\n\t\t\tdata: \"verylong\".to_owned()\n\t\t})\n\t});\n\n\twith_body(b\"data=shorter\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap_err();\n\t\tassert!(matches!(data, Error::InvalidData(_)));\n\t});\n}\n\n#[test]\nfn validate_max_length() {\n\t#[derive(Debug, FormData, PartialEq)]\n\tstruct Data {\n\t\t#[validate(max_length = 7)]\n\t\tdata: String\n\t}\n\n\twith_body(b\"data=shorter\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data {\n\t\t\tdata: \"shorter\".to_owned()\n\t\t})\n\t});\n\n\twith_body(b\"data=verylong\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap_err();\n\t\tassert!(matches!(data, Error::InvalidData(_)));\n\t});\n}\n\n#[test]\nfn validate_min() {\n\t#[derive(Debug, FormData, PartialEq)]\n\tstruct Data {\n\t\t#[validate(min = 10)]\n\t\tdata: u64\n\t}\n\n\twith_body(b\"data=10\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data { data: 10 })\n\t});\n\n\twith_body(b\"data=9\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap_err();\n\t\tassert!(matches!(data, Error::InvalidData(_)));\n\t});\n}\n\n#[test]\nfn validate_max() {\n\t#[derive(Debug, FormData, PartialEq)]\n\tstruct Data {\n\t\t#[validate(max = 10)]\n\t\tdata: u64\n\t}\n\n\twith_body(b\"data=10\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data { data: 10 })\n\t});\n\n\twith_body(b\"data=11\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap_err();\n\t\tassert!(matches!(data, Error::InvalidData(_)));\n\t});\n}\n\n#[cfg(feature = \"regex-validation\")]\n#[test]\nfn validate_regex() {\n\t#[derive(Debug, FormData, PartialEq)]\n\tstruct Data {\n\t\t#[validate(regex = \"^[a-z]+$\")]\n\t\tdata: String\n\t}\n\n\twith_body(b\"data=lower\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data {\n\t\t\tdata: \"lower\".to_owned()\n\t\t})\n\t});\n\n\twith_body(b\"data=UPPER\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap_err();\n\t\tassert!(matches!(data, Error::InvalidData(_)));\n\t});\n}\n\n#[test]\nfn validate_expected() {\n\t#[derive(Debug, FormData, PartialEq)]\n\tstruct Data {\n\t\t#[validate(expected = &[\"foo\", \"bar\"])]\n\t\tdata: String\n\t}\n\n\twith_body(b\"data=foo\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data { data: \"foo\".to_owned() })\n\t});\n\n\twith_body(b\"data=bar\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data { data: \"bar\".to_owned() })\n\t});\n\n\twith_body(b\"data=other\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap_err();\n\t\tassert!(matches!(data, Error::InvalidData(_)));\n\t});\n}\n","traces":[],"covered":0,"coverable":0}]}