{"files":[{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","derive","src","form_data","builder.rs"],"content":"use super::Field;\nuse proc_macro2::{Ident, TokenStream};\nuse syn::{ImplGenerics, TypeGenerics, WhereClause};\n\npub(super) struct FormDataBuilder<'a> {\n\tpub(super) name: &'a Ident,\n\tpub(super) ident: Ident,\n\tpub(super) impl_generics: &'a ImplGenerics<'a>,\n\tpub(super) ty_generics: &'a TypeGenerics<'a>,\n\tpub(super) where_clause: &'a WhereClause,\n\tpub(super) fields: &'a [Field]\n}\n\nimpl<'a> FormDataBuilder<'a> {\n\tpub(super) fn gen_struct(&self) -> TokenStream {\n\t\tlet ident = &self.ident;\n\t\tlet ty_generics = &self.ty_generics;\n\n\t\tlet field_names = self.fields.iter().map(|f| &f.ident);\n\t\tlet field_types = self.fields.iter().map(|f| &f.ty);\n\n\t\tquote! {\n\t\t\t#[doc(hidden)]\n\t\t\tstruct #ident #ty_generics {\n\t\t\t\t#( #field_names: ::core::option::Option<#field_types> ),*\n\t\t\t}\n\t\t}\n\t}\n\n\tpub(super) fn gen_default_impl(&self) -> TokenStream {\n\t\tlet ident = &self.ident;\n\t\tlet ty_generics = &self.ty_generics;\n\n\t\tlet field_names = self.fields.iter().map(|f| &f.ident);\n\n\t\tquote! {\n\t\t\timpl #ty_generics ::core::default::Default for #ident #ty_generics {\n\t\t\t\tfn default() -> Self {\n\t\t\t\t\tSelf {\n\t\t\t\t\t\t#( #field_names: ::core::option::Option::None ),*\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpub(super) fn gen_builder_impl(&self) -> TokenStream {\n\t\tlet name = &self.name;\n\t\tlet ident = &self.ident;\n\t\tlet impl_generics = &self.impl_generics;\n\t\tlet ty_generics = &self.ty_generics;\n\t\tlet where_clause = &self.where_clause;\n\n\t\tlet field_names = self.fields.iter().map(|f| &f.ident).collect::<Vec<_>>();\n\t\tlet field_types = self.fields.iter().map(|f| &f.ty);\n\n\t\tquote! {\n\t\t\timpl #impl_generics ::gotham_formdata::private::FormDataBuilder for #ident #ty_generics\n\t\t\t#where_clause\n\t\t\t{\n\t\t\t\ttype Data = #name #ty_generics;\n\n\t\t\t\tfn add_entry<'a>(\n\t\t\t\t\t\t&'a mut self,\n\t\t\t\t\t\tname: ::std::borrow::Cow<'a, str>,\n\t\t\t\t\t\tvalue: ::gotham_formdata::value::Value<'a, ::gotham_formdata::Error>\n\t\t\t\t) -> ::gotham_formdata::private::FormDataBuilderFuture<'a> {\n\t\t\t\t\t#[allow(unused_imports)]\n\t\t\t\t\tuse ::gotham_formdata::private::{FutureExt as _, StreamExt as _};\n\n\t\t\t\t\tasync move {\n\t\t\t\t\t\tlet name: &::core::primitive::str = &name;\n\t\t\t\t\t\tmatch name {\n\t\t\t\t\t\t\t#(stringify!(#field_names) => {\n\t\t\t\t\t\t\t\t::gotham_formdata::private::debug!(\"Found value for field {}\", name);\n\t\t\t\t\t\t\t\tlet value_parsed = ::gotham_formdata::private::Parse::<#field_types>::parse(value)\n\t\t\t\t\t\t\t\t\t.await\n\t\t\t\t\t\t\t\t\t.map_err(|err| ::gotham_formdata::Error::IllegalField(name.to_owned(), err.into()))?;\n\t\t\t\t\t\t\t\tself.#field_names.replace(value_parsed);\n\t\t\t\t\t\t\t\tOk(())\n\t\t\t\t\t\t\t},)*\n\t\t\t\t\t\t\t_ => {\n\t\t\t\t\t\t\t\t::gotham_formdata::private::debug!(\"Found an unknown field: {}\", name);\n\t\t\t\t\t\t\t\tErr(::gotham_formdata::Error::UnknownField(name.to_string()))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}.boxed()\n\t\t\t\t}\n\n\t\t\t\tfn build(self) -> ::core::result::Result<Self::Data, ::gotham_formdata::Error> {\n\t\t\t\t\t::core::result::Result::Ok(Self::Data {\n\t\t\t\t\t\t#( #field_names: self.#field_names.ok_or(::gotham_formdata::Error::MissingField(stringify!(#field_names).to_owned()))? ),*\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","derive","src","form_data","field.rs"],"content":"use proc_macro2::{Ident, Span};\nuse syn::{\n\tparse::{Parse, ParseStream},\n\tspanned::Spanned,\n\tError, Expr, Result, Token, Type\n};\n\n#[allow(dead_code)]\nstruct FieldMeta {\n\tident: Ident,\n\teq_token: Token![=],\n\texpr: Expr\n}\n\nimpl Parse for FieldMeta {\n\tfn parse(input: ParseStream<'_>) -> Result<Self> {\n\t\tOk(Self {\n\t\t\tident: input.parse()?,\n\t\t\teq_token: input.parse()?,\n\t\t\texpr: input.parse()?\n\t\t})\n\t}\n}\n\npub(super) struct Field {\n\tpub(super) ident: Ident,\n\tpub(super) ty: Type\n}\n\nimpl Field {\n\tpub(super) fn new(field: syn::Field) -> Result<Self> {\n\t\tlet span = field.span();\n\n\t\tlet mut ident = field\n\t\t\t.ident\n\t\t\t.ok_or(Error::new(span, \"Fields without an ident are not supported\"))?;\n\t\tident.set_span(Span::call_site());\n\n\t\tOk(Self { ident, ty: field.ty })\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","derive","src","form_data","mod.rs"],"content":"use crate::util::*;\nuse proc_macro2::{Span, TokenStream};\nuse std::array;\nuse syn::{\n\tAngleBracketedGenericArguments, BoundLifetimes, Data, DeriveInput, Error, Fields, GenericArgument, Lifetime,\n\tLifetimeDef, PathArguments, PredicateType, Result, TraitBound, TraitBoundModifier, Type, TypeParamBound, TypePath,\n\tWhereClause, WherePredicate\n};\n\nmod builder;\nuse builder::FormDataBuilder;\n\nmod field;\nuse field::Field;\n\npub(super) fn expand(input: DeriveInput) -> Result<TokenStream> {\n\tlet name = &input.ident;\n\n\tlet (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();\n\tlet mut where_clause = where_clause.cloned().unwrap_or_else(|| WhereClause {\n\t\twhere_token: Default::default(),\n\t\tpredicates: Default::default()\n\t});\n\n\tlet strukt = match input.data {\n\t\tData::Struct(strukt) => strukt,\n\t\t_ => {\n\t\t\treturn Err(Error::new(\n\t\t\t\tSpan::call_site(),\n\t\t\t\t\"#[derive(FormData)] can only be used on structs\"\n\t\t\t))\n\t\t},\n\t};\n\n\tlet fields = match strukt.fields {\n\t\tFields::Named(named) => named.named.into_iter().map(|field| Field::new(field)).collect_to_result()?,\n\t\tFields::Unnamed(_) => {\n\t\t\treturn Err(Error::new(\n\t\t\t\tSpan::call_site(),\n\t\t\t\t\"#[derive(FormData)] cannot be used on tuple structs\"\n\t\t\t))\n\t\t},\n\t\tFields::Unit => Vec::new()\n\t};\n\n\tfor f in &fields {\n\t\t// T: Send\n\t\twhere_clause.predicates.push(WherePredicate::Type(PredicateType {\n\t\t\tlifetimes: None,\n\t\t\tbounded_ty: f.ty.clone(),\n\t\t\tcolon_token: Default::default(),\n\t\t\tbounds: array::IntoIter::new([TypeParamBound::Trait(TraitBound {\n\t\t\t\tparen_token: None,\n\t\t\t\tmodifier: TraitBoundModifier::None,\n\t\t\t\tlifetimes: None,\n\t\t\t\tpath: path!(::std::marker::Send)\n\t\t\t})])\n\t\t\t.collect()\n\t\t}));\n\n\t\t// for<'a> Value<'a>: Parse<T>\n\t\tlet lt = format_ident!(\"gotham_formdata_value\");\n\t\twhere_clause.predicates.push(WherePredicate::Type(PredicateType {\n\t\t\tlifetimes: Some(BoundLifetimes {\n\t\t\t\tfor_token: Default::default(),\n\t\t\t\tlt_token: Default::default(),\n\t\t\t\tlifetimes: array::IntoIter::new([LifetimeDef {\n\t\t\t\t\tattrs: Vec::new(),\n\t\t\t\t\tlifetime: Lifetime {\n\t\t\t\t\t\tapostrophe: Span::call_site(),\n\t\t\t\t\t\tident: lt.clone()\n\t\t\t\t\t},\n\t\t\t\t\tcolon_token: None,\n\t\t\t\t\tbounds: Default::default()\n\t\t\t\t}])\n\t\t\t\t.collect(),\n\t\t\t\tgt_token: Default::default()\n\t\t\t}),\n\t\t\tbounded_ty: {\n\t\t\t\tlet mut path = path!(::gotham_formdata::private::Value);\n\t\t\t\tpath.segments.last_mut().unwrap().arguments =\n\t\t\t\t\tPathArguments::AngleBracketed(AngleBracketedGenericArguments {\n\t\t\t\t\t\tcolon2_token: None,\n\t\t\t\t\t\tlt_token: Default::default(),\n\t\t\t\t\t\targs: array::IntoIter::new([GenericArgument::Lifetime(Lifetime {\n\t\t\t\t\t\t\tapostrophe: Span::call_site(),\n\t\t\t\t\t\t\tident: lt\n\t\t\t\t\t\t})])\n\t\t\t\t\t\t.collect(),\n\t\t\t\t\t\tgt_token: Default::default()\n\t\t\t\t\t});\n\t\t\t\tType::Path(TypePath { qself: None, path })\n\t\t\t},\n\t\t\tcolon_token: Default::default(),\n\t\t\tbounds: array::IntoIter::new([TypeParamBound::Trait(TraitBound {\n\t\t\t\tparen_token: None,\n\t\t\t\tmodifier: TraitBoundModifier::None,\n\t\t\t\tlifetimes: None,\n\t\t\t\tpath: {\n\t\t\t\t\tlet mut path = path!(::gotham_formdata::private::Parse);\n\t\t\t\t\tpath.segments.last_mut().unwrap().arguments =\n\t\t\t\t\t\tPathArguments::AngleBracketed(AngleBracketedGenericArguments {\n\t\t\t\t\t\t\tcolon2_token: None,\n\t\t\t\t\t\t\tlt_token: Default::default(),\n\t\t\t\t\t\t\targs: array::IntoIter::new([GenericArgument::Type(f.ty.clone())]).collect(),\n\t\t\t\t\t\t\tgt_token: Default::default()\n\t\t\t\t\t\t});\n\t\t\t\t\tpath\n\t\t\t\t}\n\t\t\t})])\n\t\t\t.collect()\n\t\t}));\n\t}\n\n\tlet builder = FormDataBuilder {\n\t\tname,\n\t\tident: format_ident!(\"{}FormDataBuilder\", name),\n\t\timpl_generics: &impl_generics,\n\t\tty_generics: &ty_generics,\n\t\twhere_clause: &where_clause,\n\t\tfields: &fields\n\t};\n\tlet builder_ident = &builder.ident;\n\n\tlet builder_struct = builder.gen_struct();\n\tlet builder_default_impl = builder.gen_default_impl();\n\tlet builder_builder_impl = builder.gen_builder_impl();\n\n\tlet mut dummy = format_ident!(\"_IMPL_FORMDATA_FOR_{}\", name);\n\tdummy.set_span(Span::call_site());\n\tOk(quote! {\n\t\t#[allow(non_upper_case_globals)]\n\t\tstatic #dummy: () = {\n\t\t\t#builder_struct\n\t\t\t#builder_default_impl\n\t\t\t#builder_builder_impl\n\n\t\t\timpl #impl_generics ::gotham_formdata::FormData for #name #ty_generics\n\t\t\t#where_clause\n\t\t\t{\n\t\t\t\ttype Err = ::gotham_formdata::Error;\n\n\t\t\t\tfn parse_form_data(state: &mut ::gotham_formdata::private::State) -> ::gotham_formdata::FormDataFuture<Self> {\n\t\t\t\t\tuse ::gotham_formdata::private::FutureExt as _;\n\n\t\t\t\t\tlet content_type = ::gotham_formdata::private::get_content_type(state);\n\t\t\t\t\tlet body = ::gotham_formdata::private::get_body(state);\n\n\t\t\t\t\tasync move {\n\t\t\t\t\t\tlet content_type = content_type?;\n\t\t\t\t\t\t::gotham_formdata::private::debug!(\"Parsing Form Data for type {} with Content-Type {}\", stringify!(#name), content_type);\n\n\t\t\t\t\t\tlet res = ::gotham_formdata::private::parse::<#builder_ident #ty_generics>(body, content_type).await?;\n\t\t\t\t\t\t::gotham_formdata::private::Validate::validate(&res)?;\n\t\t\t\t\t\tOk(res)\n\t\t\t\t\t}.boxed()\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","derive","src","lib.rs"],"content":"//! This crate implements derive macros for the `gotham_formdata` crate.\n#![warn(missing_docs, rust_2018_idioms)]\n#![deny(unreachable_pub)]\n#![forbid(unsafe_code)]\n\n#[macro_use]\nextern crate quote;\n\nuse proc_macro::TokenStream;\nuse proc_macro2::TokenStream as TokenStream2;\nuse syn::{parse_macro_input, DeriveInput, Result};\n\n#[macro_use]\nmod util;\n\nmod form_data;\n\n#[inline]\nfn print_tokens(tokens: TokenStream2) -> TokenStream {\n\t//eprintln!(\"{}\", tokens);\n\ttokens.into()\n}\n\n#[inline]\nfn expand_derive<F>(input: TokenStream, expand: F) -> TokenStream\nwhere\n\tF: FnOnce(DeriveInput) -> Result<TokenStream2>\n{\n\tprint_tokens(expand(parse_macro_input!(input)).unwrap_or_else(|err| err.to_compile_error()))\n}\n\n/// This derive macro implements `FormData` for the struct it is invoked on. Enums, unions and\n/// tuple structs are not supported.\n#[proc_macro_derive(FormData, attributes(validate))]\npub fn derive_form_data(input: TokenStream) -> TokenStream {\n\texpand_derive(input, form_data::expand)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","derive","src","util.rs"],"content":"use proc_macro2::Span;\nuse syn::{Error, Path};\n\nmacro_rules! path {\n\t(:: $($segment:ident)::*) => {\n\t\tpath!(@private Some(Default::default()), $($segment),*)\n\t};\n\t($($segment:ident)::*) => {\n\t\tpath!(@private None, $($segment),*)\n\t};\n\t(@private $leading_colon:expr, $($segment:ident),*) => {\n\t\t{\n\t\t\t#[allow(unused_mut)]\n\t\t\tlet mut segments: ::syn::punctuated::Punctuated<::syn::PathSegment, _> = Default::default();\n\t\t\t$(\n\t\t\t\tsegments.push(::syn::PathSegment {\n\t\t\t\t\tident: ::proc_macro2::Ident::new(stringify!($segment), ::proc_macro2::Span::call_site()),\n\t\t\t\t\targuments: Default::default()\n\t\t\t\t});\n\t\t\t)*\n\t\t\t::syn::Path {\n\t\t\t\tleading_colon: $leading_colon,\n\t\t\t\tsegments\n\t\t\t}\n\t\t}\n\t};\n}\n\npub(crate) trait CollectToResult {\n\ttype Item;\n\n\tfn collect_to_result(self) -> Result<Vec<Self::Item>, Error>;\n}\n\nimpl<Item, I> CollectToResult for I\nwhere\n\tI: Iterator<Item = Result<Item, Error>>\n{\n\ttype Item = Item;\n\n\tfn collect_to_result(self) -> Result<Vec<Item>, Error> {\n\t\tself.fold(<Result<Vec<Item>, Error>>::Ok(Vec::new()), |res, code| match (code, res) {\n\t\t\t(Ok(code), Ok(mut codes)) => {\n\t\t\t\tcodes.push(code);\n\t\t\t\tOk(codes)\n\t\t\t},\n\t\t\t(Ok(_), Err(errors)) => Err(errors),\n\t\t\t(Err(err), Ok(_)) => Err(err),\n\t\t\t(Err(err), Err(mut errors)) => {\n\t\t\t\terrors.combine(err);\n\t\t\t\tErr(errors)\n\t\t\t}\n\t\t})\n\t}\n}\n\npub(crate) trait PathEndsWith {\n\tfn ends_with(&self, s: &str) -> bool;\n}\n\nimpl PathEndsWith for Path {\n\tfn ends_with(&self, s: &str) -> bool {\n\t\tself.segments.last().map(|segment| segment.ident.to_string()).as_deref() == Some(s)\n\t}\n}\n\npub(crate) trait WithSpan {\n\tfn with_span(self, span: Span) -> Self;\n}\n\nimpl WithSpan for Error {\n\tfn with_span(self, span: Span) -> Self {\n\t\tlet mut err: Option<Self> = None;\n\t\tfor old_err in self {\n\t\t\tlet new_err = Error::new(span, old_err);\n\t\t\terr = match err {\n\t\t\t\tSome(mut err) => {\n\t\t\t\t\terr.combine(new_err);\n\t\t\t\t\tSome(err)\n\t\t\t\t},\n\t\t\t\tNone => Some(new_err)\n\t\t\t};\n\t\t}\n\t\terr.unwrap()\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","error.rs"],"content":"use gotham::anyhow;\nuse mime::Mime;\nuse thiserror::Error;\nuse validator::ValidationErrors;\n\n#[derive(Debug, Error)]\n#[non_exhaustive]\n/// This error type is used when parsing form data from a request body was unsuccessful.\npub enum Error {\n\t/// The body of the request could not be read.\n\t#[error(\"The body of the request could not be read\")]\n\tIllegalBody(#[from] gotham::hyper::Error),\n\n\t/// The content type of the body was not a valid mime type.\n\t#[error(\"The 'Content-Type' header could not be parsed: {0}\")]\n\tIllegalContentType(#[from] mime::FromStrError),\n\n\t/// The content type of the body contained unreadable bytes.\n\t#[error(\"The 'Content-Type' header could not be parsed: {0}\")]\n\tIllegalContentTypeValue(#[from] gotham::hyper::header::ToStrError),\n\n\t/// The value of a field could not be parsed into that field's type.\n\t#[error(\"The field {0} could not be parsed: {1}\")]\n\tIllegalField(String, #[source] anyhow::Error),\n\n\t/// The body was parsed but contained data that did not pass validation.\n\t#[error(\"The body contained invalid data: {0}\")]\n\tInvalidData(#[from] ValidationErrors),\n\n\t/// An I/O error occured while reading the body.\n\t#[error(\"I/O Error while reading body: {0}\")]\n\tIoError(#[from] std::io::Error),\n\n\t/// The body was a multipart body but did not specify a boundary.\n\t#[error(\"The request failed to specify the multipart boundary\")]\n\tMissingBoundary,\n\n\t/// The request did not specify a content type.\n\t#[error(\"The request is missing a 'Content-Type' header\")]\n\tMissingContentType,\n\n\t/// One of the multipart parts is missing a `Content-Disposition` header.\n\t#[error(\"Missing a 'Content-Disposition' header\")]\n\tMissingContentDisposition,\n\n\t/// The body is missing a required field.\n\t#[error(\"Missing Field '{0}'\")]\n\tMissingField(String),\n\n\t/// The multipart format was invalid.\n\t#[error(\"Multipart error: {0}\")]\n\tMultipartError(#[from] multer::Error),\n\n\t/// The body's content type is not supported.\n\t#[error(\"Unknown 'Content-Type' header value: {0}\")]\n\tUnknownContentType(Mime),\n\n\t/// The body contained a field that was not expected.\n\t#[error(\"Unknown Field '{0}'\")]\n\tUnknownField(String)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","form_data.rs"],"content":"use gotham::state::State;\nuse std::{future::Future, pin::Pin};\n\n/// This is the return type of [FormData::parse_form_data].\n#[allow(type_alias_bounds)]\npub type FormDataFuture<T: FormData> = Pin<Box<dyn Future<Output = Result<T, T::Err>> + Send>>;\n\n/**\nThis is the trait implemented by `#[derive(FormData)]`. It provides a method to parse the struct\nit is implemented for to be parsed from the request body contained in gotham's state.\n\nYou usually don't implement this trait directly, use the derive macro instead.\n*/\npub trait FormData: Sized {\n\t/// The error type returned when parsing the request body was unsuccessful.\n\ttype Err;\n\n\t/// Parse the struct from the request body contained in gotham's state.\n\tfn parse_form_data(state: &mut State) -> FormDataFuture<Self>;\n}\n\n/**\nThis is the equivalent of [FormData] from the state's perspective. Use this if you prefer\n`state.parse_form_data::<MyData>()?` over `MyData::parse_form_data(&mut state)?`.\n*/\npub trait FormDataFromState {\n\t/// Parse `T` from the request body contained in this state.\n\tfn parse_form_data<T: FormData>(&mut self) -> FormDataFuture<T>;\n}\n\nimpl FormDataFromState for State {\n\tfn parse_form_data<T: FormData>(&mut self) -> FormDataFuture<T> {\n\t\tT::parse_form_data(self)\n\t}\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","lib.rs"],"content":"/*!\nThis crate is an extension to the popular [gotham web framework][gotham] for Rust. It aims to\nreduce boilerplate necessary to read request bodies today as a stop-gap until gotham finally\nimplements a [body extractor].\n\n# :sparkles: Features\n\n- Parse `application/x-www-form-urlencoded` request bodies\n- Parse `multipart/form-data` request bodies\n- Verify the parsed request body\n- `#![forbid(unsafe_code)]` ensures that all functionality is implemented in 100% safe Rust code\n\n# :warning: Warning\n\nThis crate is asynchronous, but does not yet enforce uploads limits. **YOU ARE RESPONSIBLE\nFOR ENFORCING UPLOAD LIMITS.**\n\n# :spiral_notepad: Example\n\n```rust\n# use gotham::handler::HandlerError;\n# use gotham::helpers::http::response::*;\n# use gotham::hyper::{Body, Response, StatusCode};\n# use gotham::state::State;\n# use mime::TEXT_PLAIN;\nuse gotham_formdata::FormData;\nuse validator::Validate;\n\n#[derive(FormData, Validate)]\nstruct LoginData {\n\t#[validate(length(min = 5, max = 16))]\n\tusername: String,\n\t#[validate(length(min = 8))]\n\tpassword: String\n}\n\nasync fn login_handler(state: &mut State) -> Result<Response<Body>, HandlerError> {\n\tlet login_data: LoginData = FormData::parse_form_data(state).await?;\n\tOk(if login_data.password == \"secret\" {\n\t\tcreate_response(state, StatusCode::OK, TEXT_PLAIN, login_data.username)\n\t} else {\n\t\tcreate_empty_response(state, StatusCode::FORBIDDEN)\n\t})\n}\n```\n\n# :label: Versioning\n\nLike all rust crates, this crate will follow semantic versioning guidelines. However, changing\nthe MSRV (minimum supported rust version) is not considered a breaking change.\n\n# :page_with_curl: License\n\n```text\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n\thttps://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```\n\n [body extractor]: https://github.com/gotham-rs/gotham/issues/11\n [gotham]: https://github.com/gotham-rs/gotham\n [multipart]: https://crates.io/crates/multipart\n*/\n\n#![warn(missing_docs, rust_2018_idioms)]\n#![deny(missing_debug_implementations, unreachable_pub)]\n#![forbid(unsafe_code)]\n\n#[doc(inline)]\npub use gotham_formdata_derive::*;\n\nmod error;\npub use error::*;\n\nmod form_data;\npub use form_data::*;\n\n#[doc(hidden)]\n/// Not public API.\npub mod private;\n\npub mod value;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","private","deserializer.rs"],"content":"use log::warn;\nuse paste::paste;\nuse serde::de::{self, DeserializeSeed, SeqAccess, Visitor};\nuse std::{\n\tborrow::{Borrow, Cow},\n\tfmt::{self, Display},\n\tops::Deref\n};\n\n#[derive(Debug)]\npub struct Error(pub(super) String);\n\nimpl de::Error for Error {\n\tfn custom<T: Display>(msg: T) -> Self {\n\t\tError(msg.to_string())\n\t}\n}\n\nimpl Display for Error {\n\tfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\t\tf.write_str(&self.0)\n\t}\n}\n\nimpl std::error::Error for Error {}\n\ntype Result<T> = std::result::Result<T, Error>;\n\n#[derive(Debug)]\npub enum Deserializer<'de> {\n\tBytes(Vec<u8>),\n\tText(Cow<'de, str>)\n}\n\nenum Borrowed<'short, 'long: 'short, T: ?Sized + ToOwned> {\n\tShort(&'short T),\n\tLong(&'long T),\n\tOwned(<T as ToOwned>::Owned)\n}\n\nimpl<'short, 'long: 'short, T: ?Sized + ToOwned> Deref for Borrowed<'short, 'long, T> {\n\ttype Target = T;\n\n\tfn deref(&self) -> &T {\n\t\tmatch *self {\n\t\t\tSelf::Short(b) => b,\n\t\t\tSelf::Long(b) => b,\n\t\t\tSelf::Owned(ref o) => o.borrow()\n\t\t}\n\t}\n}\n\nimpl<'de> Deserializer<'de> {\n\tfn text(&self) -> Borrowed<'_, 'de, str> {\n\t\tmatch &self {\n\t\t\tSelf::Bytes(b) => match String::from_utf8_lossy(&b) {\n\t\t\t\tCow::Borrowed(s) => Borrowed::Short(s),\n\t\t\t\tCow::Owned(s) => Borrowed::Owned(s)\n\t\t\t},\n\t\t\tSelf::Text(Cow::Borrowed(s)) => Borrowed::Long(s),\n\t\t\tSelf::Text(Cow::Owned(s)) => Borrowed::Short(&s)\n\t\t}\n\t}\n\n\tfn bytes(&self) -> Borrowed<'_, 'de, [u8]> {\n\t\tmatch self {\n\t\t\tSelf::Bytes(b) => Borrowed::Short(&b),\n\t\t\tSelf::Text(Cow::Borrowed(s)) => Borrowed::Long(s.as_bytes()),\n\t\t\tSelf::Text(Cow::Owned(s)) => Borrowed::Short(s.as_bytes())\n\t\t}\n\t}\n}\n\nmacro_rules! impl_deserializer {\n\t(\n\t\t$(const $const:ident = |$this:ident, $visitor:ident| { $($body:tt)* };)*\n\t\t$(parse $parse:ty;)*\n\t\t$(forward $forward:ident to $to:ident;)*\n\t\t$(fn $fn:ident<$V:ident>($this0:ident $(, $arg:ident : $ty:ty)*) { $($body0:tt)* })*\n\t) => {\n\t\ttype Error = Error;\n\n\t\tpaste! {\n\t\t\t$(\n\t\t\t\tfn $const<V>(self, $visitor: V) -> Result<V::Value>\n\t\t\t\twhere\n\t\t\t\t\tV: Visitor<'de>\n\t\t\t\t{\n\t\t\t\t\tlet $this = self;\n\t\t\t\t\t$($body)*\n\t\t\t\t}\n\t\t\t)*\n\n\t\t\t$(\n\t\t\t\tfn [<deserialize_ $parse>]<V>(self, visitor: V) -> Result<V::Value>\n\t\t\t\twhere\n\t\t\t\t\tV: Visitor<'de>\n\t\t\t\t{\n\t\t\t\t\tlet value = self.text().parse::<$parse>().map_err(|e| Error(e.to_string()))?;\n\t\t\t\t\tvisitor.[<visit_ $parse>](value)\n\t\t\t\t}\n\t\t\t)*\n\n\t\t\t$(\n\t\t\t\tfn $forward<V>(self, visitor: V) -> Result<V::Value>\n\t\t\t\twhere\n\t\t\t\t\tV: Visitor<'de>\n\t\t\t\t{\n\t\t\t\t\tself.$to(visitor)\n\t\t\t\t}\n\t\t\t)*\n\n\t\t\t$(\n\t\t\t\tfn $fn<$V>(self$(, $arg : $ty)*) -> Result<$V::Value>\n\t\t\t\twhere\n\t\t\t\t\t$V: Visitor<'de>\n\t\t\t\t{\n\t\t\t\t\tlet $this0 = self;\n\t\t\t\t\t$($body0)*\n\t\t\t\t}\n\t\t\t)*\n\t\t}\n\t};\n}\n\nimpl<'a, 'de> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n\timpl_deserializer! {\n\t\tconst deserialize_any = |this, visitor| {\n\t\t\tmatch this {\n\t\t\t\tDeserializer::Bytes(b) => visitor.visit_bytes(&b),\n\t\t\t\tDeserializer::Text(Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n\t\t\t\tDeserializer::Text(Cow::Owned(s)) => visitor.visit_str(&s)\n\t\t\t}\n\t\t};\n\n\t\tconst deserialize_bool = |this, visitor| {\n\t\t\tlet text = this.text().to_ascii_lowercase();\n\t\t\tlet value = text == \"true\" || text == \"y\" || text == \"on\" || text == \"1\";\n\t\t\tvisitor.visit_bool(value)\n\t\t};\n\n\t\tconst deserialize_str = |this, visitor| {\n\t\t\tmatch this.text() {\n\t\t\t\tBorrowed::Short(s) => visitor.visit_str(s),\n\t\t\t\tBorrowed::Long(s) => visitor.visit_borrowed_str(s),\n\t\t\t\tBorrowed::Owned(s) => visitor.visit_string(s)\n\t\t\t}\n\t\t};\n\n\t\tconst deserialize_bytes = |this, visitor| {\n\t\t\tmatch this.bytes() {\n\t\t\t\tBorrowed::Short(b) => visitor.visit_bytes(b),\n\t\t\t\tBorrowed::Long(b) => visitor.visit_borrowed_bytes(b),\n\t\t\t\tBorrowed::Owned(b) => visitor.visit_byte_buf(b)\n\t\t\t}\n\t\t};\n\n\t\tconst deserialize_seq = |this, visitor| {\n\t\t\tmatch this {\n\t\t\t\tDeserializer::Bytes(b) => visitor.visit_seq(Seq::Bytes(&b)),\n\t\t\t\tDeserializer::Text(s) => visitor.visit_seq(Seq::Text(&s))\n\t\t\t}\n\t\t};\n\n\t\tparse i8;\n\t\tparse i16;\n\t\tparse i32;\n\t\tparse i64;\n\t\tparse i128;\n\t\tparse u8;\n\t\tparse u16;\n\t\tparse u32;\n\t\tparse u64;\n\t\tparse u128;\n\t\tparse f32;\n\t\tparse f64;\n\n\t\tforward deserialize_char to deserialize_any;\n\t\tforward deserialize_string to deserialize_str;\n\t\tforward deserialize_byte_buf to deserialize_bytes;\n\t\tforward deserialize_option to deserialize_any;\n\t\tforward deserialize_unit to deserialize_any;\n\t\tforward deserialize_map to deserialize_any;\n\t\tforward deserialize_identifier to deserialize_any;\n\t\tforward deserialize_ignored_any to deserialize_any;\n\n\t\tfn deserialize_unit_struct<V>(this, _name: &'static str, visitor: V) {\n\t\t\tthis.deserialize_any(visitor)\n\t\t}\n\n\t\tfn deserialize_newtype_struct<V>(this, _name: &'static str, visitor: V) {\n\t\t\tthis.deserialize_any(visitor)\n\t\t}\n\n\t\tfn deserialize_tuple<V>(this, _len: usize, visitor: V) {\n\t\t\tthis.deserialize_any(visitor)\n\t\t}\n\n\t\tfn deserialize_tuple_struct<V>(this, _name: &'static str, _len: usize, visitor: V) {\n\t\t\tthis.deserialize_any(visitor)\n\t\t}\n\n\t\tfn deserialize_struct<V>(this, _name: &'static str, _fields: &'static [&'static str], visitor: V) {\n\t\t\tthis.deserialize_any(visitor)\n\t\t}\n\n\t\tfn deserialize_enum<V>(this, _name: &'static str, _variants: &'static [&'static str], visitor: V) {\n\t\t\tthis.deserialize_any(visitor)\n\t\t}\n\t}\n}\n\nenum Seq<'a> {\n\tBytes(&'a [u8]),\n\tText(&'a str),\n\tString(String, usize)\n}\n\nimpl Seq<'_> {\n\tfn is_empty(&self) -> bool {\n\t\tmatch self {\n\t\t\tSelf::Bytes(b) => b.is_empty(),\n\t\t\tSelf::Text(s) => s.is_empty(),\n\t\t\tSelf::String(s, i) => s.len() < *i\n\t\t}\n\t}\n}\n\nimpl<'a, 'de> SeqAccess<'de> for Seq<'a> {\n\ttype Error = Error;\n\n\tfn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>>\n\twhere\n\t\tT: DeserializeSeed<'de>\n\t{\n\t\tif self.is_empty() {\n\t\t\treturn Ok(None);\n\t\t}\n\n\t\tlet v = seed.deserialize(&mut *self)?;\n\t\tmatch self {\n\t\t\tSelf::Bytes(b) => *self = Self::Bytes(&b[1..]),\n\t\t\tSelf::Text(s) => *self = Self::Text(&s[1..]),\n\t\t\tSelf::String(_, i) => *i += 1\n\t\t};\n\t\tOk(Some(v))\n\t}\n}\n\nimpl<'a, 'b, 'de> de::Deserializer<'de> for &'a mut Seq<'b> {\n\timpl_deserializer! {\n\t\tconst deserialize_any = |this, visitor| {\n\t\t\tmatch this {\n\t\t\t\tSeq::Bytes(b) => visitor.visit_u8(b[0]),\n\t\t\t\tSeq::Text(s) => visitor.visit_char(s.chars().next().unwrap()),\n\t\t\t\tSeq::String(s, i) => visitor.visit_char(s.chars().nth(*i).unwrap())\n\t\t\t}\n\t\t};\n\n\t\tconst deserialize_u8 = |this, visitor| {\n\t\t\tmatch this {\n\t\t\t\tSeq::Bytes(b) => visitor.visit_u8(b[0]),\n\t\t\t\t// convert the string to bytes\n\t\t\t\tSeq::Text(s) => {\n\t\t\t\t\tlet bytes = s.as_bytes();\n\t\t\t\t\t*this = Seq::Bytes(bytes);\n\t\t\t\t\tvisitor.visit_u8(bytes[0])\n\t\t\t\t},\n\t\t\t\t// someone asked for a string explicitly and now wants bytes again.\n\t\t\t\t// I won't convert the string back to bytes.\n\t\t\t\tSeq::String(s, i) => {\n\t\t\t\t\twarn!(\"You asked for a char from byte sequence, and now want bytes again. Make up your mind please!\");\n\t\t\t\t\tvisitor.visit_char(s.chars().nth(*i).unwrap())\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst deserialize_char = |this, visitor| {\n\t\t\tmatch this {\n\t\t\t\t// convert the bytes to a lossy string\n\t\t\t\tSeq::Bytes(b) => {\n\t\t\t\t\tmatch String::from_utf8_lossy(b) {\n\t\t\t\t\t\tCow::Borrowed(s) => {\n\t\t\t\t\t\t\t*this = Seq::Text(s);\n\t\t\t\t\t\t\tvisitor.visit_char(s.chars().next().unwrap())\n\t\t\t\t\t\t},\n\t\t\t\t\t\tCow::Owned(s) => {\n\t\t\t\t\t\t\tlet ch = s.chars().next().unwrap();\n\t\t\t\t\t\t\t*this = Seq::String(s, 0);\n\t\t\t\t\t\t\tvisitor.visit_char(ch)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSeq::Text(s) => visitor.visit_char(s.chars().next().unwrap()),\n\t\t\t\tSeq::String(s, i) => visitor.visit_char(s.chars().nth(*i).unwrap())\n\t\t\t}\n\t\t};\n\n\t\tforward deserialize_bool to deserialize_any;\n\t\tforward deserialize_i8 to deserialize_any;\n\t\tforward deserialize_i16 to deserialize_any;\n\t\tforward deserialize_i32 to deserialize_any;\n\t\tforward deserialize_i64 to deserialize_any;\n\t\tforward deserialize_i128 to deserialize_any;\n\t\tforward deserialize_u16 to deserialize_u8;\n\t\tforward deserialize_u32 to deserialize_u8;\n\t\tforward deserialize_u64 to deserialize_u8;\n\t\tforward deserialize_u128 to deserialize_u8;\n\t\tforward deserialize_f32 to deserialize_any;\n\t\tforward deserialize_f64 to deserialize_any;\n\t\tforward deserialize_str to deserialize_any;\n\t\tforward deserialize_string to deserialize_any;\n\t\tforward deserialize_bytes to deserialize_any;\n\t\tforward deserialize_byte_buf to deserialize_any;\n\t\tforward deserialize_option to deserialize_any;\n\t\tforward deserialize_unit to deserialize_any;\n\t\tforward deserialize_seq to deserialize_any;\n\t\tforward deserialize_map to deserialize_any;\n\t\tforward deserialize_identifier to deserialize_any;\n\t\tforward deserialize_ignored_any to deserialize_any;\n\n\t\tfn deserialize_unit_struct<V>(this, _name: &'static str, visitor: V) {\n\t\t\tthis.deserialize_any(visitor)\n\t\t}\n\n\t\tfn deserialize_newtype_struct<V>(this, _name: &'static str, visitor: V) {\n\t\t\tthis.deserialize_any(visitor)\n\t\t}\n\n\t\tfn deserialize_tuple<V>(this, _len: usize, visitor: V) {\n\t\t\tthis.deserialize_any(visitor)\n\t\t}\n\n\t\tfn deserialize_tuple_struct<V>(this, _name: &'static str, _len: usize, visitor: V) {\n\t\t\tthis.deserialize_any(visitor)\n\t\t}\n\n\t\tfn deserialize_struct<V>(this, _name: &'static str, _fields: &'static [&'static str], visitor: V) {\n\t\t\tthis.deserialize_any(visitor)\n\t\t}\n\n\t\tfn deserialize_enum<V>(this, _name: &'static str, _variants: &'static [&'static str], visitor: V) {\n\t\t\tthis.deserialize_any(visitor)\n\t\t}\n\t}\n}\n","traces":[{"line":14,"address":[2007728,2007807],"length":1,"stats":{"Line":0},"fn_name":"custom<core::fmt::Arguments>"},{"line":15,"address":[2007741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[2009408],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":21,"address":[2009427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[2009488],"length":1,"stats":{"Line":5},"fn_name":"text"},{"line":55,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":57,"address":[2009770,2009749],"length":1,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[2009818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[2009569],"length":1,"stats":{"Line":4},"fn_name":null},{"line":61,"address":[2009641],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[2009936],"length":1,"stats":{"Line":0},"fn_name":"bytes"},{"line":66,"address":[2010212,2009975,2010244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[2009963,2009982,2010229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[2010022,2010197,2010106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[2124523,2124192],"length":1,"stats":{"Line":7},"fn_name":"deserialize_str<serde::de::impls::StringVisitor>"},{"line":89,"address":[2124227],"length":1,"stats":{"Line":7},"fn_name":null},{"line":95,"address":[2124544,2125055],"length":1,"stats":{"Line":1},"fn_name":"deserialize_u64<serde::de::impls::{impl#50}::deserialize::PrimitiveVisitor>"},{"line":99,"address":[2124569,2125092,2124686,2125072],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}<serde::de::impls::{impl#50}::deserialize::PrimitiveVisitor>"},{"line":100,"address":[2125038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[2125152],"length":1,"stats":{"Line":5},"fn_name":"deserialize_string<serde::de::impls::StringVisitor>"},{"line":109,"address":[2125168],"length":1,"stats":{"Line":5},"fn_name":null},{"line":142,"address":[2124217],"length":1,"stats":{"Line":5},"fn_name":null},{"line":143,"address":[2124235,2124324],"length":1,"stats":{"Line":5},"fn_name":null},{"line":144,"address":[2124521,2124331,2124251],"length":1,"stats":{"Line":9},"fn_name":null},{"line":145,"address":[2124519,2124377],"length":1,"stats":{"Line":6},"fn_name":null},{"line":146,"address":[2124420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[2037486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[2037522,2037860,2037732],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[2037529,2037779,2037510,2037862],"length":1,"stats":{"Line":3},"fn_name":null},{"line":161,"address":[2037749,2037586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[2039387,2038384],"length":1,"stats":{"Line":1},"fn_name":"next_element_seed<core::marker::PhantomData<u8>>"},{"line":236,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[2039447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[2040295,2040618,2039534,2040735],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[2039495,2039544,2040641,2040740],"length":1,"stats":{"Line":3},"fn_name":null},{"line":264,"address":[2039621],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[2039636,2040336],"length":1,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[2040471,2040367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[2040528,2040623,2040433],"length":1,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[2039715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[2039922,2039843,2039752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[2040064,2040297],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":42,"coverable":61},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","private","mod.rs"],"content":"use crate::{value::BytesOrString, Error, FormData};\nuse futures_util::{future::BoxFuture, stream::TryStreamExt};\nuse gotham::{\n\tanyhow,\n\thyper::{\n\t\tbody::{self, Body},\n\t\theader::{HeaderMap, CONTENT_TYPE}\n\t}\n};\nuse mime::{Mime, APPLICATION_WWW_FORM_URLENCODED, BOUNDARY, MULTIPART_FORM_DATA};\nuse multer::Multipart;\nuse serde::de::DeserializeOwned;\nuse std::{borrow::Cow, fmt::Display, future::Future, pin::Pin};\n\npub use futures_util::{FutureExt, StreamExt};\npub use gotham::{hyper::body::Bytes, state::State};\npub use log::debug;\npub use validator::Validate;\n\nmod deserializer;\nuse deserializer::Deserializer;\n\npub type FormDataBuilderFuture<'a> = Pin<Box<dyn Future<Output = Result<(), Error>> + Send + 'a>>;\npub type Value<'a, E = Error> = crate::value::Value<'a, E>;\n\npub trait FormDataBuilder: Default {\n\ttype Data: FormData;\n\n\tfn add_entry<'a>(&'a mut self, name: Cow<'a, str>, value: Value<'a, Error>) -> FormDataBuilderFuture<'a>;\n\tfn build(self) -> Result<Self::Data, Error>;\n}\n\npub fn get_content_type(state: &State) -> Result<Mime, Error> {\n\tlet headers: &HeaderMap = state.borrow();\n\tOk(headers\n\t\t.get(CONTENT_TYPE)\n\t\t.ok_or(Error::MissingContentType)?\n\t\t.to_str()?\n\t\t.parse()?)\n}\n\npub fn get_body(state: &mut State) -> Body {\n\tstate.take()\n}\n\npub async fn parse<T: FormDataBuilder>(body: Body, content_type: Mime) -> Result<T::Data, Error> {\n\tif is_urlencoded(&content_type) {\n\t\tparse_urlencoded::<T>(body).await\n\t} else if is_multipart(&content_type) {\n\t\tparse_multipart::<T>(body, &content_type).await\n\t} else {\n\t\tErr(Error::UnknownContentType(content_type))\n\t}\n}\n\nfn is_urlencoded(content_type: &Mime) -> bool {\n\tcontent_type.essence_str() == APPLICATION_WWW_FORM_URLENCODED.as_ref()\n}\n\nasync fn parse_urlencoded<T: FormDataBuilder>(body: Body) -> Result<T::Data, Error> {\n\tlet body = body::to_bytes(body).await?;\n\n\tlet mut builder = T::default();\n\tfor (name, value) in form_urlencoded::parse(&body) {\n\t\tlet value = Value {\n\t\t\tvalue: BytesOrString::String(value),\n\t\t\tcontent_type: None\n\t\t};\n\t\tbuilder.add_entry(name, value).await?;\n\t}\n\tbuilder.build()\n}\n\nfn is_multipart(content_type: &Mime) -> bool {\n\tcontent_type.essence_str() == MULTIPART_FORM_DATA.as_ref()\n}\n\nasync fn parse_multipart<T: FormDataBuilder>(body: Body, content_type: &Mime) -> Result<T::Data, Error> {\n\tlet boundary = content_type.get_param(BOUNDARY).ok_or(Error::MissingBoundary)?.as_str();\n\tlet mut multipart = Multipart::new(body, boundary);\n\n\tlet mut builder = T::default();\n\twhile let Some(field) = multipart.next_field().await? {\n\t\tlet name = field.name().ok_or(Error::MissingContentDisposition)?.to_owned();\n\t\tlet mime = field.content_type().cloned();\n\n\t\tlet stream = field.map_err(Into::into).boxed();\n\t\tlet value = Value {\n\t\t\tvalue: BytesOrString::Bytes(stream),\n\t\t\tcontent_type: mime\n\t\t};\n\t\tbuilder.add_entry(name.into(), value).await?;\n\t}\n\tbuilder.build()\n}\n\npub trait Parse<T> {\n\ttype Err: Into<anyhow::Error>;\n\ttype Fut: Future<Output = Result<T, Self::Err>> + Send;\n\n\tfn parse(self) -> Self::Fut;\n}\n\nimpl<'de, T, Err> Parse<T> for Value<'de, Err>\nwhere\n\tT: DeserializeOwned,\n\tErr: Display + 'static\n{\n\ttype Err = deserializer::Error;\n\ttype Fut = BoxFuture<'de, Result<T, Self::Err>>;\n\n\tfn parse(self) -> Self::Fut {\n\t\tasync move {\n\t\t\tlet mut deserializer = match self.value {\n\t\t\t\tBytesOrString::Bytes(mut stream) => {\n\t\t\t\t\tlet mut buf: Vec<u8> = Vec::new();\n\t\t\t\t\twhile let Some(data) = stream.next().await {\n\t\t\t\t\t\tbuf.extend_from_slice(&data.map_err(|e| deserializer::Error(e.to_string()))?);\n\t\t\t\t\t}\n\t\t\t\t\tDeserializer::Bytes(buf.into())\n\t\t\t\t},\n\t\t\t\tBytesOrString::String(s) => Deserializer::Text(s)\n\t\t\t};\n\t\t\tT::deserialize(&mut deserializer)\n\t\t}\n\t\t.boxed()\n\t}\n}\n","traces":[{"line":33,"address":[2468128],"length":1,"stats":{"Line":6},"fn_name":"get_content_type"},{"line":34,"address":[2468166],"length":1,"stats":{"Line":6},"fn_name":null},{"line":35,"address":[2468190,2468489,2468591,2468721,2468256,2468413,2468441,2468317],"length":1,"stats":{"Line":18},"fn_name":null},{"line":37,"address":[2468300,2468352,2468244],"length":1,"stats":{"Line":12},"fn_name":null},{"line":38,"address":[2468466],"length":1,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[2468574,2468689],"length":1,"stats":{"Line":6},"fn_name":null},{"line":42,"address":[2468768],"length":1,"stats":{"Line":6},"fn_name":"get_body"},{"line":43,"address":[2009073],"length":1,"stats":{"Line":6},"fn_name":null},{"line":46,"address":[2114614,2114110,2113782,2114942,2114526,2115030,2114198,2113694],"length":1,"stats":{"Line":45},"fn_name":null},{"line":47,"address":[2199944,2202149,2204133,2206117,2203912,2201928,2205896,2200165],"length":1,"stats":{"Line":18},"fn_name":null},{"line":48,"address":[2113737,2114985,2114153,2114569],"length":1,"stats":{"Line":16},"fn_name":null},{"line":49,"address":[2202772,2204756,2206173,2200919,2202903,2206740,2206871,2202205,2204189,2204887,2200788,2200221],"length":1,"stats":{"Line":8},"fn_name":null},{"line":50,"address":[2200003,2204897,2202913,2206881,2201987,2203971,2205955,2200929],"length":1,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[2200803,2202787,2206755,2204771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[2009088],"length":1,"stats":{"Line":6},"fn_name":"is_urlencoded"},{"line":57,"address":[2468825],"length":1,"stats":{"Line":6},"fn_name":null},{"line":60,"address":[2193589,2186896,2187374,2187191,2190414,2193216,2187136,2193268,2186960,2187024,2193692,2186880,2193448,2190670,2196256,2187630,2196308,2196488,2196629,2187008,2187072,2190176,2186944,2190231,2187088,2196732,2187527,2190567],"length":1,"stats":{"Line":32},"fn_name":"parse_urlencoded<validation::validate_min_length::_IMPL_FORMDATA_FOR_Data::DataFormDataBuilder>"},{"line":61,"address":[2116253,2117885,2116621,2118285],"length":1,"stats":{"Line":32},"fn_name":null},{"line":63,"address":[2197152,2194112,2188050,2191090,2191259,2188219],"length":1,"stats":{"Line":10},"fn_name":null},{"line":64,"address":[2198807,2192759,2194335,2197679,2188596,2197450,2197285,2188226,2194410,2195767,2197375,2194639,2188391,2197599,2188540,2191431,2194559,2191580,2191636,2191356,2188316,2194245,2189719,2191266],"length":1,"stats":{"Line":40},"fn_name":null},{"line":66,"address":[2194903,2191894,2188854,2197943],"length":1,"stats":{"Line":8},"fn_name":null},{"line":69,"address":[2116081,2116449,2117681,2118081],"length":1,"stats":{"Line":8},"fn_name":null},{"line":71,"address":[2194577,2191598,2188558,2197617],"length":1,"stats":{"Line":8},"fn_name":null},{"line":74,"address":[2009184],"length":1,"stats":{"Line":3},"fn_name":"is_multipart"},{"line":75,"address":[2009193],"length":1,"stats":{"Line":3},"fn_name":null},{"line":78,"address":[2168702,2170451,2183355,2178562,2168096,2186768,2177645,2173906,2177472,2175120,2172928,2168192,2172818,2172989,2167904,2168349,2168288,2179747,2182224,2184416,2168029,2174059,2182638,2168221,2168126,2173342,2168000,2169419,2177842,2177584,2178715,2169266,2183202,2167934,2177998,2182114,2168546,2182285,2173186,2182482],"length":1,"stats":{"Line":20},"fn_name":"parse_multipart<validation::validate_max_length::_IMPL_FORMDATA_FOR_Data::DataFormDataBuilder>"},{"line":79,"address":[2173945,2169305,2182784,2173488,2178058,2182698,2169231,2178527,2168486,2178601,2173126,2183167,2173402,2168848,2177782,2168762,2183241,2182422,2178144,2173871],"length":1,"stats":{"Line":16},"fn_name":null},{"line":80,"address":[2173961,2183257,2178617,2169321,2169458,2178754,2174098,2183394],"length":1,"stats":{"Line":8},"fn_name":null},{"line":82,"address":[2178757,2169461,2183397,2174101],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[2169561,2174918,2182512,2183499,2173216,2174376,2179521,2183561,2174265,2182597,2178857,2184214,2173301,2168661,2170225,2169672,2178968,2181588,2177872,2176963,2168576,2183672,2186259,2169502,2174203,2178798,2177957,2172292],"length":1,"stats":{"Line":24},"fn_name":null},{"line":84,"address":[2179815,2174960,2175188,2179893,2170267,2170922,2184484,2184562,2184256,2170984,2175591,2179563,2175653,2170519,2180280,2175266,2184887,2170597,2180218,2184949],"length":1,"stats":{"Line":16},"fn_name":null},{"line":85,"address":[2175784,2180350,2185080,2171054,2180284,2171115,2170988,2175723,2184953,2180411,2185019,2175657],"length":1,"stats":{"Line":12},"fn_name":null},{"line":87,"address":[2171119,2180415,2180567,2171271,2175940,2185084,2175788,2185236],"length":1,"stats":{"Line":8},"fn_name":null},{"line":89,"address":[2180583,2185252,2171287,2175956],"length":1,"stats":{"Line":4},"fn_name":null},{"line":92,"address":[2115719,2115351,2116855,2117271],"length":1,"stats":{"Line":8},"fn_name":null},{"line":94,"address":[2175017,2184313,2170324,2179620],"length":1,"stats":{"Line":4},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":7},"fn_name":null}],"covered":45,"coverable":46},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","value.rs"],"content":"/*!\nThis mod defines the [Value] used for parsing the form data.\n*/\n\nuse bytes::Bytes;\nuse futures_util::stream::Stream;\nuse std::{\n\tborrow::Cow,\n\tfmt::{self, Debug},\n\tpin::Pin\n};\n\npub use mime::Mime;\n\n/// A stream of bytes.\npub type ByteStream<Err> = Pin<Box<dyn Stream<Item = Result<Bytes, Err>> + Send>>;\n\n/// Either a stream of bytes or a string.\npub enum BytesOrString<'a, Err> {\n\t/// Byte stream.\n\tBytes(ByteStream<Err>),\n\t/// String.\n\tString(Cow<'a, str>)\n}\n\nimpl<'a, Err> Debug for BytesOrString<'a, Err> {\n\tfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\t\tmatch self {\n\t\t\tSelf::Bytes(_) => write!(f, \"BytesOrString::Bytes(...)\"),\n\t\t\tSelf::String(_) => write!(f, \"BytesOrString::String(...)\")\n\t\t}\n\t}\n}\n\n/// A value, either a string parsed from and urlencoded form, or bytes from a multipart body.\n#[derive(Debug)]\npub struct Value<'a, Err> {\n\t/// The value of the field.\n\tpub value: BytesOrString<'a, Err>,\n\t/// The content-type of the field, if any.\n\tpub content_type: Option<Mime>\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","multipart.rs"],"content":"use gotham::{\n\thandler::HandlerError,\n\thelpers::http::response::*,\n\thyper::{Body, Response, StatusCode},\n\trouter::builder::*,\n\tstate::State,\n\ttest::TestServer\n};\nuse gotham_formdata::FormData;\nuse mime::{Mime, TEXT_PLAIN};\nuse validator::Validate;\n\n#[derive(FormData, Validate)]\nstruct LoginData {\n\tusername: String,\n\tpassword: String\n}\n\nasync fn login_handler(state: &mut State) -> Result<Response<Body>, HandlerError> {\n\tlet login_data: LoginData = FormData::parse_form_data(state).await?;\n\tOk(if login_data.password == \"secret\" {\n\t\tcreate_response(state, StatusCode::OK, TEXT_PLAIN, login_data.username)\n\t} else {\n\t\tcreate_empty_response(state, StatusCode::FORBIDDEN)\n\t})\n}\n\n#[test]\nfn multipart() {\n\tlet _ = pretty_env_logger::try_init_timed();\n\n\tlet server = TestServer::new(build_simple_router(|router| {\n\t\trouter.post(\"/login\").to_async_borrowing(login_handler);\n\t}))\n\t.unwrap();\n\n\tlet mime: Mime = \"multipart/form-data; boundary=GOTHAMMULTIPART\".parse().unwrap();\n\tlet body = \"--GOTHAMMULTIPART\\r\\nContent-Disposition: form-data; name=\\\"username\\\"\\r\\n\\r\\ntestuser\\r\\n--GOTHAMMULTIPART\\r\\nContent-Disposition: form-data; name=\\\"password\\\"\\r\\n\\r\\nsecret\\r\\n--GOTHAMMULTIPART--\\r\\n\";\n\tlet res = server.client().post(\"http://localhost/login\", body, mime).perform().unwrap();\n\tlet body = res.read_body().unwrap();\n\tassert_eq!(&body, b\"testuser\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","trybuild_ui.rs"],"content":"use trybuild::TestCases;\n\n#[test]\nfn trybuild_ui() {\n\tlet t = TestCases::new();\n\tt.compile_fail(\"tests/ui/*.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","types.rs"],"content":"use futures_executor::block_on;\nuse gotham::{\n\thyper::{\n\t\tbody::Body,\n\t\theader::{HeaderMap, CONTENT_TYPE}\n\t},\n\tstate::State\n};\nuse gotham_formdata::FormData;\nuse mime::{Mime, APPLICATION_WWW_FORM_URLENCODED};\nuse percent_encoding::{percent_encode, NON_ALPHANUMERIC};\nuse validator::Validate;\n\nfn with_body(body: &[u8], content_type: Mime, callback: impl Fn(&mut State)) {\n\tState::with_new(|state| {\n\t\tlet body: Body = body.to_owned().into();\n\t\tstate.put(body);\n\n\t\tlet mut headers = HeaderMap::new();\n\t\theaders.insert(CONTENT_TYPE, content_type.to_string().parse().unwrap());\n\t\tstate.put(headers);\n\n\t\tcallback(state);\n\t});\n}\n\nfn with_body_foo(foo: &[u8], callback: impl Fn(&mut State)) {\n\tlet urlencoded = format!(\"foo={}\", percent_encode(foo, NON_ALPHANUMERIC));\n\twith_body(urlencoded.as_bytes(), APPLICATION_WWW_FORM_URLENCODED, &callback);\n\n\tlet mut multipart = Vec::new();\n\tmultipart.extend_from_slice(b\"--GOTHAM-MULTIPART-BOUNDARY\\r\\nContent-Disposition: form-data; name=\\\"foo\\\"\\r\\n\\r\\n\");\n\tmultipart.extend_from_slice(foo);\n\tmultipart.extend_from_slice(b\"\\r\\n--GOTHAM-MULTIPART-BOUNDARY--\");\n\tlet mime = \"multipart/form-data; boundary=GOTHAM-MULTIPART-BOUNDARY\";\n\twith_body(&multipart, mime.parse().unwrap(), &callback);\n}\n\n#[test]\nfn test_string() {\n\t#[derive(Debug, FormData, PartialEq, Validate)]\n\tstruct Data {\n\t\tfoo: String\n\t}\n\n\twith_body_foo(\n\t\tb\"\\xF0\\x9F\\x9A\\xA2 DONAUDAMPFSCHIFFFAHRTSKAPIT\\xC3\\x84NSM\\xC3\\x9CTZE \\xF0\\x9F\\x91\\xAE\",\n\t\t|state| {\n\t\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\t\tassert_eq!(data, Data {\n\t\t\t\tfoo: \"🚢 DONAUDAMPFSCHIFFFAHRTSKAPITÄNSMÜTZE 👮\".to_owned()\n\t\t\t});\n\t\t}\n\t);\n}\n\n#[test]\nfn test_vec_u8() {\n\t#[derive(Debug, FormData, PartialEq, Validate)]\n\tstruct Data {\n\t\tfoo: Vec<u8>\n\t}\n\n\twith_body_foo(\n\t\tb\"\\xF0\\x9F\\x9A\\xA2 DONAUDAMPFSCHIFFFAHRTSKAPIT\\xC3\\x84NSM\\xC3\\x9CTZE \\xF0\\x9F\\x91\\xAE\",\n\t\t|state| {\n\t\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\t\tassert_eq!(data, Data {\n\t\t\t\tfoo: \"🚢 DONAUDAMPFSCHIFFFAHRTSKAPITÄNSMÜTZE 👮\".as_bytes().to_owned()\n\t\t\t});\n\t\t}\n\t);\n}\n\n#[test]\nfn test_generic() {\n\t#[derive(Debug, PartialEq, Validate)]\n\tstruct Data<T> {\n\t\tfoo: T\n\t}\n\n\t#[allow(non_upper_case_globals)]\n\tstatic _IMPL_FORMDATA_FOR_Data: () = {\n\t\t#[doc(hidden)]\n\t\tstruct DataFormDataBuilder<T> {\n\t\t\tfoo: ::core::option::Option<T>\n\t\t}\n\t\timpl<T> ::core::default::Default for DataFormDataBuilder<T> {\n\t\t\tfn default() -> Self {\n\t\t\t\tSelf {\n\t\t\t\t\tfoo: ::core::option::Option::None\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\timpl<T> ::gotham_formdata::private::FormDataBuilder for DataFormDataBuilder<T>\n\t\twhere\n\t\t\tT: ::std::marker::Send,\n\t\t\tfor<'a> ::gotham_formdata::private::Value<'a>: ::gotham_formdata::private::Parse<T>\n\t\t{\n\t\t\ttype Data = Data<T>;\n\t\t\tfn add_entry<'a>(\n\t\t\t\t&'a mut self,\n\t\t\t\tname: ::std::borrow::Cow<'a, str>,\n\t\t\t\tvalue: ::gotham_formdata::value::Value<'a, ::gotham_formdata::Error>\n\t\t\t) -> ::gotham_formdata::private::FormDataBuilderFuture<'a> {\n\t\t\t\t#[allow(unused_imports)]\n\t\t\t\tuse ::gotham_formdata::private::{FutureExt as _, StreamExt as _};\n\t\t\t\tasync move {\n\t\t\t\t\tlet name: &::core::primitive::str = &name;\n\t\t\t\t\tmatch name {\n\t\t\t\t\t\t\"foo\" => {\n\t\t\t\t\t\t\tlet value_parsed = ::gotham_formdata::private::Parse::<T>::parse(value)\n\t\t\t\t\t\t\t\t.await\n\t\t\t\t\t\t\t\t.map_err(|err| ::gotham_formdata::Error::IllegalField(name.to_owned(), err.into()))?;\n\t\t\t\t\t\t\tself.foo.replace(value_parsed);\n\t\t\t\t\t\t\tOk(())\n\t\t\t\t\t\t},\n\t\t\t\t\t\t_ => Err(::gotham_formdata::Error::UnknownField(name.to_string()))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t.boxed()\n\t\t\t}\n\t\t\tfn build(self) -> ::core::result::Result<Self::Data, ::gotham_formdata::Error> {\n\t\t\t\t::core::result::Result::Ok(Self::Data {\n\t\t\t\t\tfoo: self.foo.ok_or(::gotham_formdata::Error::MissingField(\"foo\".to_owned()))?\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\timpl<T> ::gotham_formdata::FormData for Data<T>\n\t\twhere\n\t\t\tT: ::std::marker::Send,\n\t\t\tfor<'a> ::gotham_formdata::private::Value<'a>: ::gotham_formdata::private::Parse<T>\n\t\t{\n\t\t\ttype Err = ::gotham_formdata::Error;\n\t\t\tfn parse_form_data(state: &mut ::gotham_formdata::private::State) -> ::gotham_formdata::FormDataFuture<Self> {\n\t\t\t\tuse ::gotham_formdata::private::FutureExt as _;\n\t\t\t\tlet content_type = ::gotham_formdata::private::get_content_type(state);\n\t\t\t\tlet body = ::gotham_formdata::private::get_body(state);\n\t\t\t\tasync move {\n\t\t\t\t\tlet content_type = content_type?;\n\t\t\t\t\tlet res = ::gotham_formdata::private::parse::<DataFormDataBuilder<T>>(body, content_type).await?;\n\t\t\t\t\t::gotham_formdata::private::Validate::validate(&res)?;\n\t\t\t\t\tOk(res)\n\t\t\t\t}\n\t\t\t\t.boxed()\n\t\t\t}\n\t\t}\n\t};\n\n\twith_body_foo(b\"bar\", |state| {\n\t\tlet data = block_on(Data::<String>::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data { foo: \"bar\".to_owned() })\n\t});\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","form_data_enum.rs"],"content":"use gotham_formdata::FormData;\n\n#[derive(FormData)]\nenum MyFormData {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","form_data_missing_validate.rs"],"content":"use gotham_formdata::FormData;\n\nstruct MyType;\n\n#[derive(FormData)]\nstruct MyFormData {\n\tfoo: String\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","form_data_tuple_struct.rs"],"content":"use gotham_formdata::FormData;\n\n#[derive(FormData)]\nstruct MyFormData(String);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","form_data_union.rs"],"content":"use gotham_formdata::FormData;\n\n#[derive(FormData)]\nunion MyFormData {\n\tfoo: u8,\n\tbar: i8\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","form_data_unparsable.rs"],"content":"use gotham_formdata::FormData;\nuse validator::Validate;\n\nstruct MyType;\n\n#[derive(FormData, Validate)]\nstruct MyFormData {\n\tfoo: MyType\n}\n\nfn assert_formdata<T: FormData>() {}\n\nfn main() {\n\tassert_formdata::<MyFormData>();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","urlencoded.rs"],"content":"use gotham::{\n\thandler::HandlerError,\n\thelpers::http::response::*,\n\thyper::{Body, Response, StatusCode},\n\trouter::builder::*,\n\tstate::State,\n\ttest::TestServer\n};\nuse gotham_formdata::FormData;\nuse mime::{Mime, TEXT_PLAIN};\nuse validator::Validate;\n\n#[derive(FormData, Validate)]\nstruct LoginData {\n\tusername: String,\n\tpassword: String\n}\n\nasync fn login_handler(state: &mut State) -> Result<Response<Body>, HandlerError> {\n\tlet login_data: LoginData = FormData::parse_form_data(state).await?;\n\tOk(if login_data.password == \"secret\" {\n\t\tcreate_response(state, StatusCode::OK, TEXT_PLAIN, login_data.username)\n\t} else {\n\t\tcreate_empty_response(state, StatusCode::FORBIDDEN)\n\t})\n}\n\n#[test]\nfn urlencoded() {\n\tlet _ = pretty_env_logger::try_init_timed();\n\n\tlet server = TestServer::new(build_simple_router(|router| {\n\t\trouter.post(\"/login\").to_async_borrowing(login_handler);\n\t}))\n\t.unwrap();\n\n\tlet mime: Mime = \"application/x-www-form-urlencoded\".parse().unwrap();\n\tlet body = \"username=testuser&password=secret\";\n\tlet res = server.client().post(\"http://localhost/login\", body, mime).perform().unwrap();\n\tlet body = res.read_body().unwrap();\n\tassert_eq!(&body, b\"testuser\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","validation.rs"],"content":"use futures_executor::block_on;\nuse gotham::{\n\thyper::{\n\t\theader::{HeaderMap, CONTENT_TYPE},\n\t\tBody\n\t},\n\tstate::State\n};\nuse gotham_formdata::{Error, FormData};\nuse mime::{Mime, APPLICATION_WWW_FORM_URLENCODED};\nuse validator::Validate;\n\nfn with_body(body: &'static [u8], content_type: Mime, callback: impl Fn(&mut State)) {\n\tState::with_new(|state| {\n\t\tlet body: Body = body.into();\n\t\tstate.put(body);\n\n\t\tlet mut headers = HeaderMap::new();\n\t\theaders.insert(CONTENT_TYPE, content_type.to_string().parse().unwrap());\n\t\tstate.put(headers);\n\n\t\tcallback(state);\n\t});\n}\n\n#[test]\nfn validate_min_length() {\n\t#[derive(Debug, FormData, PartialEq, Validate)]\n\tstruct Data {\n\t\t#[validate(length(min = 8))]\n\t\tdata: String\n\t}\n\n\twith_body(b\"data=verylong\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data {\n\t\t\tdata: \"verylong\".to_owned()\n\t\t})\n\t});\n\n\twith_body(b\"data=shorter\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state));\n\t\tassert!(matches!(data, Err(Error::InvalidData(_))));\n\t});\n}\n\n#[test]\nfn validate_max_length() {\n\t#[derive(Debug, FormData, PartialEq, Validate)]\n\tstruct Data {\n\t\t#[validate(length(max = 7))]\n\t\tdata: String\n\t}\n\n\twith_body(b\"data=shorter\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data {\n\t\t\tdata: \"shorter\".to_owned()\n\t\t})\n\t});\n\n\twith_body(b\"data=verylong\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state));\n\t\tassert!(matches!(data, Err(Error::InvalidData(_))));\n\t});\n}\n\n#[test]\nfn validate_min() {\n\t#[derive(Debug, FormData, PartialEq, Validate)]\n\tstruct Data {\n\t\t#[validate(range(min = 10))]\n\t\tdata: u64\n\t}\n\n\twith_body(b\"data=10\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data { data: 10 })\n\t});\n\n\twith_body(b\"data=9\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state));\n\t\tassert!(matches!(data, Err(Error::InvalidData(_))));\n\t});\n}\n\n#[test]\nfn validate_max() {\n\t#[derive(Debug, FormData, PartialEq, Validate)]\n\tstruct Data {\n\t\t#[validate(range(max = 10))]\n\t\tdata: u64\n\t}\n\n\twith_body(b\"data=10\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data { data: 10 })\n\t});\n\n\twith_body(b\"data=11\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state));\n\t\tassert!(matches!(data, Err(Error::InvalidData(_))));\n\t});\n}\n","traces":[],"covered":0,"coverable":0}]}