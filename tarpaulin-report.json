{"files":[{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","derive","src","form_data","builder.rs"],"content":"use super::Field;\nuse proc_macro2::{Ident, TokenStream};\nuse syn::Generics;\n\npub(super) struct FormDataBuilder<'a> {\n\tpub(super) name: &'a Ident,\n\tpub(super) ident: Ident,\n\tpub(super) generics: &'a Generics,\n\tpub(super) fields: &'a [Field]\n}\n\nimpl<'a> FormDataBuilder<'a> {\n\tpub(super) fn gen_struct(&self) -> TokenStream {\n\t\tlet ident = &self.ident;\n\t\tlet (impl_gen, _, were) = self.generics.split_for_impl();\n\n\t\tlet field_names = self.fields.iter().map(|f| &f.ident);\n\t\tlet field_types = self.fields.iter().map(|f| &f.ty);\n\n\t\tquote! {\n\t\t\t#[doc(hidden)]\n\t\t\tstruct #ident #impl_gen #were {\n\t\t\t\t#( #field_names: Option<#field_types> ),*\n\t\t\t}\n\t\t}\n\t}\n\n\tpub(super) fn gen_default_impl(&self) -> TokenStream {\n\t\tlet ident = &self.ident;\n\t\tlet (impl_gen, ty_gen, were) = self.generics.split_for_impl();\n\n\t\tlet field_names = self.fields.iter().map(|f| &f.ident);\n\n\t\tquote! {\n\t\t\timpl #impl_gen Default for #ident #ty_gen #were {\n\t\t\t\tfn default() -> Self {\n\t\t\t\t\tSelf {\n\t\t\t\t\t\t#( #field_names: None ),*\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpub(super) fn gen_builder_impl(&self) -> TokenStream {\n\t\tlet name = &self.name;\n\t\tlet ident = &self.ident;\n\t\tlet (impl_gen, ty_gen, were) = self.generics.split_for_impl();\n\n\t\tlet field_names = self.fields.iter().map(|f| &f.ident).collect::<Vec<_>>();\n\t\tlet field_types = self.fields.iter().map(|f| &f.ty);\n\n\t\tquote! {\n\t\t\timpl #impl_gen ::gotham_formdata::private::FormDataBuilder for #ident #ty_gen #were {\n\t\t\t\ttype Data = #name #ty_gen;\n\n\t\t\t\tfn add_entry<'a>(\n\t\t\t\t\t\t&'a mut self,\n\t\t\t\t\t\tname: ::std::borrow::Cow<'a, str>,\n\t\t\t\t\t\tvalue: ::gotham_formdata::value::Value<'a, ::gotham_formdata::Error>\n\t\t\t\t) -> ::gotham_formdata::private::FormDataBuilderFuture<'a> {\n\t\t\t\t\t#[allow(unused_imports)]\n\t\t\t\t\tuse ::gotham_formdata::{conversion::prelude::*, private::{FutureExt, StreamExt}};\n\n\t\t\t\t\tasync move {\n\t\t\t\t\t\tlet name: &str = &name;\n\t\t\t\t\t\tmatch name {\n\t\t\t\t\t\t\t#(stringify!(#field_names) => {\n\t\t\t\t\t\t\t\tlog::debug!(\"Found value for field {}\", name);\n\t\t\t\t\t\t\t\tlet value_parsed = <#field_types>::convert_value(name, value).await?;\n\t\t\t\t\t\t\t\tself.#field_names.replace(value_parsed);\n\t\t\t\t\t\t\t\tOk(())\n\t\t\t\t\t\t\t},)*\n\t\t\t\t\t\t\t_ => {\n\t\t\t\t\t\t\t\tlog::debug!(\"Found an unknown field: {}\", name);\n\t\t\t\t\t\t\t\tErr(::gotham_formdata::Error::UnknownField(name.to_string()))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}.boxed()\n\t\t\t\t}\n\n\t\t\t\tfn build(self) -> Result<#name #ty_gen, ::gotham_formdata::Error> {\n\t\t\t\t\tOk(#name #ty_gen {\n\t\t\t\t\t\t#( #field_names: self.#field_names.ok_or(::gotham_formdata::Error::MissingField(stringify!(#field_names).to_owned()))? ),*\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","derive","src","form_data","field.rs"],"content":"use proc_macro2::{Ident, Span};\nuse syn::{\n\tparse::{Parse, ParseStream},\n\tspanned::Spanned,\n\tError, Expr, Result, Token, Type\n};\n\n#[allow(dead_code)]\nstruct FieldMeta {\n\tident: Ident,\n\teq_token: Token![=],\n\texpr: Expr\n}\n\nimpl Parse for FieldMeta {\n\tfn parse(input: ParseStream<'_>) -> Result<Self> {\n\t\tOk(Self {\n\t\t\tident: input.parse()?,\n\t\t\teq_token: input.parse()?,\n\t\t\texpr: input.parse()?\n\t\t})\n\t}\n}\n\npub(super) struct Field {\n\tpub(super) ident: Ident,\n\tpub(super) ty: Type\n}\n\nimpl Field {\n\tpub(super) fn new(field: syn::Field) -> Result<Self> {\n\t\tlet span = field.span();\n\n\t\tlet mut ident = field\n\t\t\t.ident\n\t\t\t.ok_or(Error::new(span, \"Fields without an ident are not supported\"))?;\n\t\tident.set_span(Span::call_site());\n\n\t\tOk(Self { ident, ty: field.ty })\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","derive","src","form_data","mod.rs"],"content":"use crate::util::*;\nuse proc_macro2::{Span, TokenStream};\nuse syn::{Data, DeriveInput, Error, Fields, Result};\n\nmod builder;\nuse builder::FormDataBuilder;\n\nmod field;\nuse field::Field;\n\npub(super) fn expand(input: DeriveInput) -> Result<TokenStream> {\n\tlet name = &input.ident;\n\tlet (impl_gen, ty_gen, were) = input.generics.split_for_impl();\n\tlet strukt = match input.data {\n\t\tData::Struct(strukt) => strukt,\n\t\t_ => {\n\t\t\treturn Err(Error::new(\n\t\t\t\tSpan::call_site(),\n\t\t\t\t\"#[derive(FormData)] can only be used on structs\"\n\t\t\t))\n\t\t},\n\t};\n\n\tlet fields = match strukt.fields {\n\t\tFields::Named(named) => named.named.into_iter().map(|field| Field::new(field)).collect_to_result()?,\n\t\tFields::Unnamed(_) => {\n\t\t\treturn Err(Error::new(\n\t\t\t\tSpan::call_site(),\n\t\t\t\t\"#[derive(FormData)] cannot be used on tuple structs\"\n\t\t\t))\n\t\t},\n\t\tFields::Unit => Vec::new()\n\t};\n\n\tlet builder = FormDataBuilder {\n\t\tname,\n\t\tident: format_ident!(\"{}FormDataBuilder\", name),\n\t\tgenerics: &input.generics,\n\t\tfields: &fields\n\t};\n\tlet builder_ident = &builder.ident;\n\n\tlet builder_struct = builder.gen_struct();\n\tlet builder_default_impl = builder.gen_default_impl();\n\tlet builder_builder_impl = builder.gen_builder_impl();\n\n\tlet mut dummy = format_ident!(\"_IMPL_FORMDATA_FOR_{}\", name);\n\tdummy.set_span(Span::call_site());\n\tOk(quote! {\n\t\t#[allow(non_upper_case_globals)]\n\t\tstatic #dummy: () = {\n\t\t\t#builder_struct\n\t\t\t#builder_default_impl\n\t\t\t#builder_builder_impl\n\n\t\t\timpl #impl_gen ::gotham_formdata::FormData for #name #ty_gen #were {\n\t\t\t\ttype Err = ::gotham_formdata::Error;\n\n\t\t\t\tfn parse_form_data(state: &mut ::gotham_formdata::private::State) -> ::gotham_formdata::FormDataFuture<Self> {\n\t\t\t\t\tuse ::gotham_formdata::private::FutureExt as _;\n\n\t\t\t\t\tlet content_type = ::gotham_formdata::private::get_content_type(state);\n\t\t\t\t\tlet body = ::gotham_formdata::private::get_body(state);\n\n\t\t\t\t\tasync move {\n\t\t\t\t\t\tlet content_type = content_type?;\n\t\t\t\t\t\t::log::debug!(\"Parsing Form Data for type {} with Content-Type {}\", stringify!(#name), content_type);\n\n\t\t\t\t\t\tlet res = ::gotham_formdata::private::parse::<#builder_ident #ty_gen>(body, content_type).await?;\n\t\t\t\t\t\t::gotham_formdata::private::Validate::validate(&res)?;\n\t\t\t\t\t\tOk(res)\n\t\t\t\t\t}.boxed()\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","derive","src","lib.rs"],"content":"//! This crate implements derive macros for the `gotham_formdata` crate.\n#![warn(missing_docs, rust_2018_idioms)]\n#![deny(unreachable_pub)]\n#![forbid(unsafe_code)]\n\n#[macro_use]\nextern crate quote;\n\nuse proc_macro::TokenStream;\nuse proc_macro2::TokenStream as TokenStream2;\nuse syn::{parse_macro_input, DeriveInput, Result};\n\nmod form_data;\nmod util;\n\n#[inline]\nfn print_tokens(tokens: TokenStream2) -> TokenStream {\n\t//eprintln!(\"{}\", tokens);\n\ttokens.into()\n}\n\n#[inline]\nfn expand_derive<F>(input: TokenStream, expand: F) -> TokenStream\nwhere\n\tF: FnOnce(DeriveInput) -> Result<TokenStream2>\n{\n\tprint_tokens(expand(parse_macro_input!(input)).unwrap_or_else(|err| err.to_compile_error()))\n}\n\n/// This derive macro implements `FormData` for the struct it is invoked on. Enums, unions and\n/// tuple structs are not supported.\n#[proc_macro_derive(FormData, attributes(validate))]\npub fn derive_form_data(input: TokenStream) -> TokenStream {\n\texpand_derive(input, form_data::expand)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","derive","src","util.rs"],"content":"use proc_macro2::Span;\nuse syn::{Error, Path};\n\npub(crate) trait CollectToResult {\n\ttype Item;\n\n\tfn collect_to_result(self) -> Result<Vec<Self::Item>, Error>;\n}\n\nimpl<Item, I> CollectToResult for I\nwhere\n\tI: Iterator<Item = Result<Item, Error>>\n{\n\ttype Item = Item;\n\n\tfn collect_to_result(self) -> Result<Vec<Item>, Error> {\n\t\tself.fold(<Result<Vec<Item>, Error>>::Ok(Vec::new()), |res, code| match (code, res) {\n\t\t\t(Ok(code), Ok(mut codes)) => {\n\t\t\t\tcodes.push(code);\n\t\t\t\tOk(codes)\n\t\t\t},\n\t\t\t(Ok(_), Err(errors)) => Err(errors),\n\t\t\t(Err(err), Ok(_)) => Err(err),\n\t\t\t(Err(err), Err(mut errors)) => {\n\t\t\t\terrors.combine(err);\n\t\t\t\tErr(errors)\n\t\t\t}\n\t\t})\n\t}\n}\n\npub(crate) trait PathEndsWith {\n\tfn ends_with(&self, s: &str) -> bool;\n}\n\nimpl PathEndsWith for Path {\n\tfn ends_with(&self, s: &str) -> bool {\n\t\tself.segments.last().map(|segment| segment.ident.to_string()).as_deref() == Some(s)\n\t}\n}\n\npub(crate) trait WithSpan {\n\tfn with_span(self, span: Span) -> Self;\n}\n\nimpl WithSpan for Error {\n\tfn with_span(self, span: Span) -> Self {\n\t\tlet mut err: Option<Self> = None;\n\t\tfor old_err in self {\n\t\t\tlet new_err = Error::new(span, old_err);\n\t\t\terr = match err {\n\t\t\t\tSome(mut err) => {\n\t\t\t\t\terr.combine(new_err);\n\t\t\t\t\tSome(err)\n\t\t\t\t},\n\t\t\t\tNone => Some(new_err)\n\t\t\t};\n\t\t}\n\t\terr.unwrap()\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","conversion.rs"],"content":"/*!\nThis mod contains conversion traits for common used types, that allows them to be created from\na stream of bytes. Furthermore, it allows every type that implements [FromStr] plus some other\ncommon types to be converted.\n\nYou cannot implement any of these traits manually. This is intentional. Instead, if you want to\nprovide a custom conversion method, just implement it as a method for your type:\n\n```rust\nuse futures_util::{FutureExt, StreamExt};\nuse gotham_formdata::{conversion::ConversionFuture, value::{BytesOrString, Value}, FormData};\nuse validator::Validate;\n\n/// This type parses Base64-encoded values to a [Vec<u8>].\nstruct Base64(Vec<u8>);\n\nimpl Base64 {\n\t// the method signature needs to be roughly equivalent to this\n\tasync fn convert_value(\n\t\t\tname: &str,\n\t\t\tvalue: Value<'_, gotham_formdata::Error>\n\t) -> Result<Self, gotham_formdata::Error> {\n\t\tlet decoded = match value.value {\n\t\t\tBytesOrString::Bytes(mut stream) => {\n\t\t\t\tlet mut buf: Vec<u8> = Vec::new();\n\t\t\t\twhile let Some(data) = stream.next().await {\n\t\t\t\t\tbuf.extend_from_slice(&data?);\n\t\t\t\t}\n\t\t\t\tbase64::decode(&buf)\n\t\t\t},\n\t\t\tBytesOrString::String(string) => base64::decode(string.as_bytes())\n\t\t}.map_err(|err| gotham_formdata::Error::IllegalField(name.to_owned(), err.into()))?;\n\n\t\tOk(Self(decoded))\n\t}\n}\n\n#[derive(FormData, Validate)]\nstruct MyData {\n\tfoo: Base64\n}\n# mod base64 { pub fn decode(input: &[u8]) -> Result<Vec<u8>, std::convert::Infallible> { unimplemented!() } }\n```\n*/\n\nuse crate::{\n\tvalue::{BytesOrString, Value},\n\tError\n};\nuse bytes::{Bytes, BytesMut};\nuse futures_util::{future::FutureExt, stream::StreamExt};\nuse gotham::anyhow;\nuse std::{future::Future, pin::Pin, str::FromStr};\n\n/// Re-exports for use in derive macro.\n#[doc(hidden)]\npub mod prelude {\n\tpub use super::{ConvertFromStr, ConvertRawBytes};\n}\n\nmod private {\n\t/// This trait ensures that none of the conversion traits can be implemented manually.\n\tpub trait Sealed1 {}\n\n\t/// This trait ensures that none of the conversion traits can be implemented manually.\n\tpub trait Sealed2 {}\n}\n\n/// The future returned from conversion methods.\npub type ConversionFuture<'a, T, Err> = Pin<Box<dyn Future<Output = Result<T, Err>> + Send + 'a>>;\n\n/// This trait is used to convert types that implement [FromStr] from a stream of bytes.\n///\n/// It is not possible to implement this trait manually. This is intentional. Look at the\n/// [module documentation](self) for an example how to convert custom types.\npub trait ConvertFromStr<Err>: private::Sealed1 + Sized {\n\t/// Perform the conversion.\n\tfn convert_value<'a>(name: &'a str, value: Value<'a, Err>) -> ConversionFuture<'a, Self, Err>;\n}\n\nimpl<T> private::Sealed1 for T\nwhere\n\tT: FromStr,\n\tT::Err: Into<anyhow::Error>\n{\n}\n\nimpl<T> ConvertFromStr<Error> for T\nwhere\n\tT: FromStr,\n\tT::Err: Into<anyhow::Error>\n{\n\tfn convert_value<'a>(name: &'a str, value: Value<'a, Error>) -> ConversionFuture<'a, Self, Error> {\n\t\tasync move {\n\t\t\tlet buf = match value.value {\n\t\t\t\tBytesOrString::Bytes(mut stream) => {\n\t\t\t\t\tlet mut buf = String::new();\n\t\t\t\t\twhile let Some(data) = stream.next().await {\n\t\t\t\t\t\tlet data = data?;\n\t\t\t\t\t\tlet str = String::from_utf8_lossy(data.as_ref());\n\t\t\t\t\t\tbuf.push_str(&str);\n\t\t\t\t\t}\n\t\t\t\t\tbuf.into()\n\t\t\t\t},\n\t\t\t\tBytesOrString::String(buf) => buf\n\t\t\t};\n\n\t\t\tbuf.parse::<Self>()\n\t\t\t\t.map_err(|err| Error::IllegalField(name.to_owned(), err.into()))\n\t\t}\n\t\t.boxed()\n\t}\n}\n\n/// This trait is used to convert `Vec<u8>` and similar types from a stream of bytes.\n///\n/// It is not possible to implement this trait manually. This is intentional. Look at the\n/// [module documentation](self) for an example how to convert custom types.\npub trait ConvertRawBytes<'a, Err>: private::Sealed2 + Sized {\n\t/// Perform the conversion.\n\tfn convert_value(name: &'a str, value: Value<'a, Err>) -> ConversionFuture<'a, Self, Err>;\n}\n\nimpl private::Sealed2 for Vec<u8> {}\n\nimpl<'a, Err: 'a> ConvertRawBytes<'a, Err> for Vec<u8> {\n\tfn convert_value(_name: &'a str, value: Value<'a, Err>) -> ConversionFuture<'a, Self, Err> {\n\t\tasync move {\n\t\t\tmatch value.value {\n\t\t\t\tBytesOrString::Bytes(mut stream) => {\n\t\t\t\t\tlet mut buf: Vec<u8> = Vec::new();\n\t\t\t\t\twhile let Some(data) = stream.next().await {\n\t\t\t\t\t\tbuf.extend_from_slice(&data?);\n\t\t\t\t\t}\n\t\t\t\t\tOk(buf)\n\t\t\t\t},\n\t\t\t\tBytesOrString::String(string) => Ok(string.as_bytes().to_vec())\n\t\t\t}\n\t\t}\n\t\t.boxed()\n\t}\n}\n\nimpl private::Sealed2 for BytesMut {}\n\nimpl<'a, Err: 'a> ConvertRawBytes<'a, Err> for BytesMut {\n\tfn convert_value(_name: &'a str, value: Value<'a, Err>) -> ConversionFuture<'a, Self, Err> {\n\t\tasync move {\n\t\t\tmatch value.value {\n\t\t\t\tBytesOrString::Bytes(mut stream) => {\n\t\t\t\t\tlet mut buf = BytesMut::new();\n\t\t\t\t\twhile let Some(data) = stream.next().await {\n\t\t\t\t\t\tbuf.extend_from_slice(&data?);\n\t\t\t\t\t}\n\t\t\t\t\tOk(buf)\n\t\t\t\t},\n\t\t\t\tBytesOrString::String(string) => Ok(string.as_bytes().into())\n\t\t\t}\n\t\t}\n\t\t.boxed()\n\t}\n}\n\nimpl private::Sealed2 for Bytes {}\n\nimpl<'a, Err: 'a> ConvertRawBytes<'a, Err> for Bytes {\n\tfn convert_value(name: &'a str, value: Value<'a, Err>) -> ConversionFuture<'a, Self, Err> {\n\t\tBytesMut::convert_value(name, value).map(|res| res.map(Into::into)).boxed()\n\t}\n}\n","traces":[{"line":93,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":94,"address":[3660420,3660346,3661649,3660224,3660267],"length":1,"stats":{"Line":15},"fn_name":"{generator#0}<alloc::string::String>"},{"line":95,"address":[3660320,3660480],"length":1,"stats":{"Line":5},"fn_name":null},{"line":96,"address":[3660487,3660327],"length":1,"stats":{"Line":7},"fn_name":null},{"line":97,"address":[3660509],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":99,"address":[3661737,3661693,3661837,3662107,3661150],"length":1,"stats":{"Line":4},"fn_name":null},{"line":100,"address":[3662193,3661811],"length":1,"stats":{"Line":4},"fn_name":null},{"line":101,"address":[3662258],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[3661308],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[3660531],"length":1,"stats":{"Line":4},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":109,"address":[3662470,3661511,3662448],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}<alloc::string::String>"},{"line":127,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":31,"coverable":33},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","error.rs"],"content":"use gotham::anyhow;\nuse mime::Mime;\nuse thiserror::Error;\nuse validator::ValidationErrors;\n\n#[derive(Debug, Error)]\n#[non_exhaustive]\n/// This error type is used when parsing form data from a request body was unsuccessful.\npub enum Error {\n\t/// The body of the request could not be read.\n\t#[error(\"The body of the request could not be read\")]\n\tIllegalBody(#[from] gotham::hyper::Error),\n\t/// The content type of the body was not a valid mime type.\n\t#[error(\"The 'Content-Type' header could not be parsed: {0}\")]\n\tIllegalContentType(#[from] mime::FromStrError),\n\t/// The content type of the body contained unreadable bytes.\n\t#[error(\"The 'Content-Type' header could not be parsed: {0}\")]\n\tIllegalContentTypeValue(#[from] gotham::hyper::header::ToStrError),\n\t/// The value of a field could not be parsed into that field's type.\n\t#[error(\"The field {0} could not be parsed: {1}\")]\n\tIllegalField(String, #[source] anyhow::Error),\n\t/// The body was parsed but contained data that did not pass validation.\n\t#[error(\"The body contained invalid data: {0}\")]\n\tInvalidData(#[from] ValidationErrors),\n\t/// An I/O error occured while reading the body.\n\t#[error(\"I/O Error while reading body: {0}\")]\n\tIoError(#[from] std::io::Error),\n\t/// The body was a multipart body but did not specify a boundary.\n\t#[error(\"The request failed to specify the multipart boundary\")]\n\tMissingBoundary,\n\t/// The request did not specify a content type.\n\t#[error(\"The request is missing a 'Content-Type' header\")]\n\tMissingContentType,\n\t/// One of the multipart parts is missing a `Content-Disposition` header.\n\t#[error(\"Missing a 'Content-Disposition' header\")]\n\tMissingContentDisposition,\n\t/// The body is missing a required field.\n\t#[error(\"Missing Field '{0}'\")]\n\tMissingField(String),\n\t/// The multipart format was invalid.\n\t#[error(\"Multipart error: {0}\")]\n\tMultipartError(#[from] multer::Error),\n\t/// The body's content type is not supported.\n\t#[error(\"Unknown 'Content-Type' header value: {0}\")]\n\tUnknownContentType(Mime),\n\t/// The body contained a field that was not expected.\n\t#[error(\"Unknown Field '{0}'\")]\n\tUnknownField(String)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","form_data.rs"],"content":"use gotham::state::State;\nuse std::{future::Future, pin::Pin};\n\n/// This is the return type of [FormData::parse_form_data].\n#[allow(type_alias_bounds)]\npub type FormDataFuture<T: FormData> = Pin<Box<dyn Future<Output = Result<T, T::Err>> + Send>>;\n\n/**\nThis is the trait implemented by `#[derive(FormData)]`. It provides a method to parse the struct\nit is implemented for to be parsed from the request body contained in gotham's state.\n\nYou usually don't implement this trait directly, use the derive macro instead.\n*/\npub trait FormData: Sized {\n\t/// The error type returned when parsing the request body was unsuccessful.\n\ttype Err;\n\n\t/// Parse the struct from the request body contained in gotham's state.\n\tfn parse_form_data(state: &mut State) -> FormDataFuture<Self>;\n}\n\n/**\nThis is the equivalent of [FormData] from the state's perspective. Use this if you prefer\n`state.parse_form_data::<MyData>()?` over `MyData::parse_form_data(&mut state)?`.\n*/\npub trait FormDataFromState {\n\t/// Parse `T` from the request body contained in this state.\n\tfn parse_form_data<T: FormData>(&mut self) -> FormDataFuture<T>;\n}\n\nimpl FormDataFromState for State {\n\tfn parse_form_data<T: FormData>(&mut self) -> FormDataFuture<T> {\n\t\tT::parse_form_data(self)\n\t}\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","lib.rs"],"content":"/*!\nThis crate is an extension to the popular [gotham web framework][gotham] for Rust. It aims to\nreduce boilerplate necessary to read request bodies today as a stop-gap until gotham finally\nimplements a [body extractor].\n\n# :sparkles: Features\n\n- Parse `application/x-www-form-urlencoded` request bodies\n- Parse `multipart/form-data` request bodies\n- Verify the parsed request body\n- `#![forbid(unsafe_code)]` ensures that all functionality is implemented in 100% safe Rust code\n\n# :warning: Warning\n\nThis crate is asynchronous, but does not yet enforce uploads limits. **YOU ARE RESPONSIBLE\nFOR ENFORCING UPLOAD LIMITS.**\n\n# :spiral_notepad: Example\n\n```rust\n# use gotham::handler::HandlerError;\n# use gotham::helpers::http::response::*;\n# use gotham::hyper::{Body, Response, StatusCode};\n# use gotham::state::State;\n# use mime::TEXT_PLAIN;\nuse gotham_formdata::FormData;\nuse validator::Validate;\n\n#[derive(FormData, Validate)]\nstruct LoginData {\n\t#[validate(length(min = 5, max = 16))]\n\tusername: String,\n\t#[validate(length(min = 8))]\n\tpassword: String\n}\n\nasync fn login_handler(state: &mut State) -> Result<Response<Body>, HandlerError> {\n\tlet login_data: LoginData = FormData::parse_form_data(state).await?;\n\tOk(if login_data.password == \"secret\" {\n\t\tcreate_response(state, StatusCode::OK, TEXT_PLAIN, login_data.username)\n\t} else {\n\t\tcreate_empty_response(state, StatusCode::FORBIDDEN)\n\t})\n}\n```\n\n# :label: Versioning\n\nLike all rust crates, this crate will follow semantic versioning guidelines. However, changing\nthe MSRV (minimum supported rust version) is not considered a breaking change.\n\n# :page_with_curl: License\n\n```text\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n\thttps://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```\n\n [body extractor]: https://github.com/gotham-rs/gotham/issues/11\n [gotham]: https://github.com/gotham-rs/gotham\n [multipart]: https://crates.io/crates/multipart\n*/\n\n#![warn(missing_docs, rust_2018_idioms)]\n#![deny(missing_debug_implementations, unreachable_pub)]\n#![forbid(unsafe_code)]\n\n#[doc(inline)]\npub use gotham_formdata_derive::*;\n\npub mod conversion;\n\nmod error;\npub use error::*;\n\nmod form_data;\npub use form_data::*;\n\n#[doc(hidden)]\n/// Not public API.\npub mod private;\n\npub mod value;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","private.rs"],"content":"use crate::{\n\tvalue::{BytesOrString, Value},\n\tError, FormData\n};\nuse futures_util::stream::TryStreamExt;\nuse gotham::hyper::{\n\tbody::{self, Body},\n\theader::{HeaderMap, CONTENT_TYPE}\n};\nuse mime::{Mime, APPLICATION_WWW_FORM_URLENCODED, BOUNDARY, MULTIPART_FORM_DATA};\nuse multer::Multipart;\nuse std::{borrow::Cow, future::Future, pin::Pin};\n\npub use futures_util::{FutureExt, StreamExt};\npub use gotham::{hyper::body::Bytes, state::State};\npub use validator::Validate;\n\n#[cfg(feature = \"regex-validation\")]\npub use regex::Regex;\n#[cfg(feature = \"regex-validation\")]\npub type LazyRegex = once_cell::sync::Lazy<Regex>;\n\npub type FormDataBuilderFuture<'a> = Pin<Box<dyn Future<Output = Result<(), Error>> + Send + 'a>>;\n\npub trait FormDataBuilder: Default {\n\ttype Data: FormData;\n\n\tfn add_entry<'a>(&'a mut self, name: Cow<'a, str>, value: Value<'a, Error>) -> FormDataBuilderFuture<'a>;\n\tfn build(self) -> Result<Self::Data, Error>;\n}\n\npub fn get_content_type(state: &State) -> Result<Mime, Error> {\n\tlet headers: &HeaderMap = state.borrow();\n\tOk(headers\n\t\t.get(CONTENT_TYPE)\n\t\t.ok_or(Error::MissingContentType)?\n\t\t.to_str()?\n\t\t.parse()?)\n}\n\npub fn get_body(state: &mut State) -> Body {\n\tstate.take()\n}\n\npub async fn parse<T: FormDataBuilder>(body: Body, content_type: Mime) -> Result<T::Data, Error> {\n\tif is_urlencoded(&content_type) {\n\t\tparse_urlencoded::<T>(body).await\n\t} else if is_multipart(&content_type) {\n\t\tparse_multipart::<T>(body, &content_type).await\n\t} else {\n\t\tErr(Error::UnknownContentType(content_type))\n\t}\n}\n\nfn is_urlencoded(content_type: &Mime) -> bool {\n\tcontent_type.essence_str() == APPLICATION_WWW_FORM_URLENCODED.as_ref()\n}\n\nasync fn parse_urlencoded<T: FormDataBuilder>(body: Body) -> Result<T::Data, Error> {\n\tlet body = body::to_bytes(body).await?;\n\n\tlet mut builder = T::default();\n\tfor (name, value) in form_urlencoded::parse(&body) {\n\t\tlet value = Value {\n\t\t\tvalue: BytesOrString::String(value),\n\t\t\tcontent_type: None\n\t\t};\n\t\tbuilder.add_entry(name, value).await?;\n\t}\n\tbuilder.build()\n}\n\nfn is_multipart(content_type: &Mime) -> bool {\n\tcontent_type.essence_str() == MULTIPART_FORM_DATA.as_ref()\n}\n\nasync fn parse_multipart<T: FormDataBuilder>(body: Body, content_type: &Mime) -> Result<T::Data, Error> {\n\tlet boundary = content_type.get_param(BOUNDARY).ok_or(Error::MissingBoundary)?.as_str();\n\tlet mut multipart = Multipart::new(body, boundary);\n\n\tlet mut builder = T::default();\n\twhile let Some(field) = multipart.next_field().await? {\n\t\tlet name = field.name().ok_or(Error::MissingContentDisposition)?.to_owned();\n\t\tlet mime = field.content_type().cloned();\n\n\t\tlet stream = field.map_err(Into::into).boxed();\n\t\tlet value = Value {\n\t\t\tvalue: BytesOrString::Bytes(stream),\n\t\t\tcontent_type: mime\n\t\t};\n\t\tbuilder.add_entry(name.into(), value).await?;\n\t}\n\tbuilder.build()\n}\n","traces":[{"line":32,"address":[4620160],"length":1,"stats":{"Line":5},"fn_name":"get_content_type"},{"line":33,"address":[4620198],"length":1,"stats":{"Line":5},"fn_name":null},{"line":34,"address":[4620445,4620222,4620349,4620753,4620623,4620521,4620473,4620288],"length":1,"stats":{"Line":15},"fn_name":null},{"line":36,"address":[4620276,4620332,4620384],"length":1,"stats":{"Line":10},"fn_name":null},{"line":37,"address":[4620498],"length":1,"stats":{"Line":5},"fn_name":null},{"line":38,"address":[4620721,4620606],"length":1,"stats":{"Line":5},"fn_name":null},{"line":41,"address":[4620800],"length":1,"stats":{"Line":5},"fn_name":"get_body"},{"line":42,"address":[4620817],"length":1,"stats":{"Line":5},"fn_name":null},{"line":45,"address":[3326862,3326950],"length":1,"stats":{"Line":50},"fn_name":null},{"line":46,"address":[2216008,2216229],"length":1,"stats":{"Line":20},"fn_name":null},{"line":47,"address":[2216125,2216052,2216317],"length":1,"stats":{"Line":18},"fn_name":null},{"line":48,"address":[4016375,4015677,4016244],"length":1,"stats":{"Line":10},"fn_name":null},{"line":49,"address":[3334833],"length":1,"stats":{"Line":5},"fn_name":null},{"line":51,"address":[4016259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[4620848],"length":1,"stats":{"Line":5},"fn_name":"is_urlencoded"},{"line":56,"address":[4620857],"length":1,"stats":{"Line":5},"fn_name":null},{"line":59,"address":[4011968,4012248,4012389,4012016,4011952,4012068,4012492],"length":1,"stats":{"Line":36},"fn_name":"parse_urlencoded<urlencoded::_IMPL_FORMDATA_FOR_LoginData::LoginDataFormDataBuilder>"},{"line":60,"address":[4012272,4012351,4012956,4012174,4012533,4012923,4012457],"length":1,"stats":{"Line":36},"fn_name":null},{"line":62,"address":[4012912],"length":1,"stats":{"Line":12},"fn_name":null},{"line":63,"address":[4013135,4013210,4013371,4013045,4013463,4014591],"length":1,"stats":{"Line":45},"fn_name":null},{"line":65,"address":[4013727],"length":1,"stats":{"Line":9},"fn_name":null},{"line":68,"address":[3338305],"length":1,"stats":{"Line":9},"fn_name":null},{"line":70,"address":[4013389],"length":1,"stats":{"Line":9},"fn_name":null},{"line":73,"address":[4620944],"length":1,"stats":{"Line":2},"fn_name":"is_multipart"},{"line":74,"address":[4620953],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[4007554,4011847,4007710,4007296,4007357,4008427,4007229,4009480,4008274,4007200],"length":1,"stats":{"Line":25},"fn_name":"parse_multipart<urlencoded::_IMPL_FORMDATA_FOR_LoginData::LoginDataFormDataBuilder>"},{"line":78,"address":[4008313,4007770,4007856,4008239,4007494],"length":1,"stats":{"Line":20},"fn_name":null},{"line":79,"address":[4008329,4008466],"length":1,"stats":{"Line":10},"fn_name":null},{"line":81,"address":[4008469],"length":1,"stats":{"Line":5},"fn_name":null},{"line":82,"address":[4011321,4007584,4008689,4009242,4007669,4008510,4008569],"length":1,"stats":{"Line":30},"fn_name":null},{"line":83,"address":[4010013,4009626,4009548,4009284,4009951],"length":1,"stats":{"Line":20},"fn_name":null},{"line":84,"address":[4010144,4010017,4010083],"length":1,"stats":{"Line":15},"fn_name":null},{"line":86,"address":[4010148,4010300],"length":1,"stats":{"Line":10},"fn_name":null},{"line":88,"address":[4010316],"length":1,"stats":{"Line":5},"fn_name":null},{"line":91,"address":[3337559],"length":1,"stats":{"Line":10},"fn_name":null},{"line":93,"address":[4009341],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":35,"coverable":36},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","src","value.rs"],"content":"/*!\nThis mod defines the [Value] used for parsing the form data.\n*/\n\nuse bytes::Bytes;\nuse futures_util::stream::Stream;\nuse std::{\n\tborrow::Cow,\n\tfmt::{self, Debug},\n\tpin::Pin\n};\n\npub use mime::Mime;\n\n/// A stream of bytes.\npub type ByteStream<Err> = Pin<Box<dyn Stream<Item = Result<Bytes, Err>> + Send>>;\n\n/// Either a stream of bytes or a string.\npub enum BytesOrString<'a, Err> {\n\t/// Byte stream.\n\tBytes(ByteStream<Err>),\n\t/// String.\n\tString(Cow<'a, str>)\n}\n\nimpl<'a, Err> Debug for BytesOrString<'a, Err> {\n\tfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\t\tmatch self {\n\t\t\tSelf::Bytes(_) => write!(f, \"BytesOrString::Bytes(...)\"),\n\t\t\tSelf::String(_) => write!(f, \"BytesOrString::String(...)\")\n\t\t}\n\t}\n}\n\n/// A value, either a string parsed from and urlencoded form, or bytes from a multipart body.\n#[derive(Debug)]\npub struct Value<'a, Err> {\n\t/// The value of the field.\n\tpub value: BytesOrString<'a, Err>,\n\t/// The content-type of the field, if any.\n\tpub content_type: Option<Mime>\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","multipart.rs"],"content":"use gotham::{\n\thandler::HandlerError,\n\thelpers::http::response::*,\n\thyper::{Body, Response, StatusCode},\n\trouter::builder::*,\n\tstate::State,\n\ttest::TestServer\n};\nuse gotham_formdata::FormData;\nuse mime::{Mime, TEXT_PLAIN};\nuse validator::Validate;\n\n#[derive(FormData, Validate)]\nstruct LoginData {\n\tusername: String,\n\tpassword: String\n}\n\nasync fn login_handler(state: &mut State) -> Result<Response<Body>, HandlerError> {\n\tlet login_data: LoginData = FormData::parse_form_data(state).await?;\n\tOk(if login_data.password == \"secret\" {\n\t\tcreate_response(state, StatusCode::OK, TEXT_PLAIN, login_data.username)\n\t} else {\n\t\tcreate_empty_response(state, StatusCode::FORBIDDEN)\n\t})\n}\n\n#[test]\nfn multipart() {\n\tlet _ = pretty_env_logger::try_init_timed();\n\n\tlet server = TestServer::new(build_simple_router(|router| {\n\t\trouter.post(\"/login\").to_async_borrowing(login_handler);\n\t}))\n\t.unwrap();\n\n\tlet mime: Mime = \"multipart/form-data; boundary=GOTHAMMULTIPART\".parse().unwrap();\n\tlet body = \"--GOTHAMMULTIPART\\r\\nContent-Disposition: form-data; name=\\\"username\\\"\\r\\n\\r\\ntestuser\\r\\n--GOTHAMMULTIPART\\r\\nContent-Disposition: form-data; name=\\\"password\\\"\\r\\n\\r\\nsecret\\r\\n--GOTHAMMULTIPART--\\r\\n\";\n\tlet res = server.client().post(\"http://localhost/login\", body, mime).perform().unwrap();\n\tlet body = res.read_body().unwrap();\n\tassert_eq!(&body, b\"testuser\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","trybuild_ui.rs"],"content":"use trybuild::TestCases;\n\n#[test]\nfn trybuild_ui() {\n\tlet t = TestCases::new();\n\tt.compile_fail(\"tests/ui/*.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","types.rs"],"content":"use futures_executor::block_on;\nuse gotham::{\n\thyper::{\n\t\tbody::{Body, Bytes},\n\t\theader::{HeaderMap, CONTENT_TYPE}\n\t},\n\tstate::State\n};\nuse gotham_formdata::FormData;\nuse mime::{Mime, APPLICATION_WWW_FORM_URLENCODED};\nuse percent_encoding::{percent_encode, NON_ALPHANUMERIC};\nuse std::{convert::Infallible, str::FromStr};\nuse validator::Validate;\n\nfn with_body(body: &[u8], content_type: Mime, callback: impl Fn(&mut State)) {\n\tState::with_new(|state| {\n\t\tlet body: Body = body.to_owned().into();\n\t\tstate.put(body);\n\n\t\tlet mut headers = HeaderMap::new();\n\t\theaders.insert(CONTENT_TYPE, content_type.to_string().parse().unwrap());\n\t\tstate.put(headers);\n\n\t\tcallback(state);\n\t});\n}\n\nfn with_body_foo(foo: &[u8], callback: impl Fn(&mut State)) {\n\tlet urlencoded = format!(\"foo={}\", percent_encode(foo, NON_ALPHANUMERIC));\n\twith_body(urlencoded.as_bytes(), APPLICATION_WWW_FORM_URLENCODED, &callback);\n\n\tlet mut multipart = Vec::new();\n\tmultipart.extend_from_slice(b\"--GOTHAM-MULTIPART-BOUNDARY\\r\\nContent-Disposition: form-data; name=\\\"foo\\\"\\r\\n\\r\\n\");\n\tmultipart.extend_from_slice(foo);\n\tmultipart.extend_from_slice(b\"\\r\\n--GOTHAM-MULTIPART-BOUNDARY--\");\n\tlet mime = \"multipart/form-data; boundary=GOTHAM-MULTIPART-BOUNDARY\";\n\twith_body(&multipart, mime.parse().unwrap(), &callback);\n}\n\n#[test]\nfn test_custom_from_str_and_convert() {\n\tuse gotham_formdata::value::Value;\n\n\t#[derive(Debug)]\n\tstruct CustomType(bool);\n\n\timpl FromStr for CustomType {\n\t\ttype Err = Infallible;\n\n\t\tfn from_str(_: &str) -> Result<Self, Infallible> {\n\t\t\tOk(Self(false))\n\t\t}\n\t}\n\n\timpl CustomType {\n\t\tasync fn convert_value<E>(_name: &str, _value: Value<'_, E>) -> Result<Self, E> {\n\t\t\tOk(Self(true))\n\t\t}\n\t}\n\n\t#[derive(Debug, FormData, Validate)]\n\tstruct Data {\n\t\tfoo: CustomType\n\t}\n\n\twith_body_foo(b\"\", |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert!(data.foo.0);\n\t})\n}\n\n#[test]\nfn test_string() {\n\t#[derive(Debug, FormData, PartialEq, Validate)]\n\tstruct Data {\n\t\tfoo: String\n\t}\n\n\twith_body_foo(\n\t\tb\"\\xF0\\x9F\\x9A\\xA2 DONAUDAMPFSCHIFFFAHRTSKAPIT\\xC3\\x84NSM\\xC3\\x9CTZE \\xF0\\x9F\\x91\\xAE\",\n\t\t|state| {\n\t\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\t\tassert_eq!(data, Data {\n\t\t\t\tfoo: \"🚢 DONAUDAMPFSCHIFFFAHRTSKAPITÄNSMÜTZE 👮\".to_owned()\n\t\t\t});\n\t\t}\n\t);\n}\n\n#[test]\nfn test_vec_u8() {\n\t#[derive(Debug, FormData, PartialEq, Validate)]\n\tstruct Data {\n\t\tfoo: Vec<u8>\n\t}\n\n\twith_body_foo(\n\t\tb\"\\xF0\\x9F\\x9A\\xA2 DONAUDAMPFSCHIFFFAHRTSKAPIT\\xC3\\x84NSM\\xC3\\x9CTZE \\xF0\\x9F\\x91\\xAE\",\n\t\t|state| {\n\t\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\t\tassert_eq!(data, Data {\n\t\t\t\tfoo: \"🚢 DONAUDAMPFSCHIFFFAHRTSKAPITÄNSMÜTZE 👮\".as_bytes().to_owned()\n\t\t\t});\n\t\t}\n\t);\n}\n\n#[test]\nfn test_bytes() {\n\t#[derive(Debug, FormData, PartialEq, Validate)]\n\tstruct Data {\n\t\tfoo: Bytes\n\t}\n\n\twith_body_foo(\n\t\tb\"\\xF0\\x9F\\x9A\\xA2 DONAUDAMPFSCHIFFFAHRTSKAPIT\\xC3\\x84NSM\\xC3\\x9CTZE \\xF0\\x9F\\x91\\xAE\",\n\t\t|state| {\n\t\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\t\tassert_eq!(data, Data {\n\t\t\t\tfoo: \"🚢 DONAUDAMPFSCHIFFFAHRTSKAPITÄNSMÜTZE 👮\".as_bytes().into()\n\t\t\t});\n\t\t}\n\t);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","convert_from_str_sealed.rs"],"content":"use futures_util::FutureExt;\nuse gotham_formdata::{\n\tconversion::{ConversionFuture, ConvertFromStr},\n\tvalue::Value\n};\n\nstruct MyType;\n\nimpl<E> ConvertFromStr<E> for MyType {\n\tfn convert_value<'a>(name: &'a str, value: Value<'a, E>) -> ConversionFuture<'a, Self, E> {\n\t\tasync move { Ok(MyType) }.boxed()\n\t}\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","convert_raw_bytes_sealed.rs"],"content":"use futures_util::FutureExt;\nuse gotham_formdata::{\n\tconversion::{ConversionFuture, ConvertRawBytes},\n\tvalue::Value\n};\n\nstruct MyType;\n\nimpl<'a, E: 'a> ConvertRawBytes<'a, E> for MyType {\n\tfn convert_value(_name: &'a str, _value: Value<'a, E>) -> ConversionFuture<'a, Self, E> {\n\t\tasync move { Ok(MyType) }.boxed()\n\t}\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","form_data_enum.rs"],"content":"use gotham_formdata::FormData;\n\n#[derive(FormData)]\nenum MyFormData {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","form_data_missing_validate.rs"],"content":"use gotham_formdata::FormData;\n\nstruct MyType;\n\n#[derive(FormData)]\nstruct MyFormData {\n\tfoo: String\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","form_data_tuple_struct.rs"],"content":"use gotham_formdata::FormData;\n\n#[derive(FormData)]\nstruct MyFormData(String);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","form_data_union.rs"],"content":"use gotham_formdata::FormData;\n\n#[derive(FormData)]\nunion MyFormData {\n\tfoo: u8,\n\tbar: i8\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","ui","form_data_unparsable.rs"],"content":"use gotham_formdata::FormData;\nuse validator::Validate;\n\nstruct MyType;\n\n#[derive(FormData, Validate)]\nstruct MyFormData {\n\tfoo: MyType\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","urlencoded.rs"],"content":"use gotham::{\n\thandler::HandlerError,\n\thelpers::http::response::*,\n\thyper::{Body, Response, StatusCode},\n\trouter::builder::*,\n\tstate::State,\n\ttest::TestServer\n};\nuse gotham_formdata::FormData;\nuse mime::{Mime, TEXT_PLAIN};\nuse validator::Validate;\n\n#[derive(FormData, Validate)]\nstruct LoginData {\n\tusername: String,\n\tpassword: String\n}\n\nasync fn login_handler(state: &mut State) -> Result<Response<Body>, HandlerError> {\n\tlet login_data: LoginData = FormData::parse_form_data(state).await?;\n\tOk(if login_data.password == \"secret\" {\n\t\tcreate_response(state, StatusCode::OK, TEXT_PLAIN, login_data.username)\n\t} else {\n\t\tcreate_empty_response(state, StatusCode::FORBIDDEN)\n\t})\n}\n\n#[test]\nfn urlencoded() {\n\tlet _ = pretty_env_logger::try_init_timed();\n\n\tlet server = TestServer::new(build_simple_router(|router| {\n\t\trouter.post(\"/login\").to_async_borrowing(login_handler);\n\t}))\n\t.unwrap();\n\n\tlet mime: Mime = \"application/x-www-form-urlencoded\".parse().unwrap();\n\tlet body = \"username=testuser&password=secret\";\n\tlet res = server.client().post(\"http://localhost/login\", body, mime).perform().unwrap();\n\tlet body = res.read_body().unwrap();\n\tassert_eq!(&body, b\"testuser\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_formdata","gotham_formdata","tests","validation.rs"],"content":"use futures_executor::block_on;\nuse gotham::{\n\thyper::{\n\t\theader::{HeaderMap, CONTENT_TYPE},\n\t\tBody\n\t},\n\tstate::State\n};\nuse gotham_formdata::{Error, FormData};\nuse mime::{Mime, APPLICATION_WWW_FORM_URLENCODED};\nuse validator::Validate;\n\nfn with_body(body: &'static [u8], content_type: Mime, callback: impl Fn(&mut State)) {\n\tState::with_new(|state| {\n\t\tlet body: Body = body.into();\n\t\tstate.put(body);\n\n\t\tlet mut headers = HeaderMap::new();\n\t\theaders.insert(CONTENT_TYPE, content_type.to_string().parse().unwrap());\n\t\tstate.put(headers);\n\n\t\tcallback(state);\n\t});\n}\n\n#[test]\nfn validate_min_length() {\n\t#[derive(Debug, FormData, PartialEq, Validate)]\n\tstruct Data {\n\t\t#[validate(length(min = 8))]\n\t\tdata: String\n\t}\n\n\twith_body(b\"data=verylong\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data {\n\t\t\tdata: \"verylong\".to_owned()\n\t\t})\n\t});\n\n\twith_body(b\"data=shorter\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state));\n\t\tassert!(matches!(data, Err(Error::InvalidData(_))));\n\t});\n}\n\n#[test]\nfn validate_max_length() {\n\t#[derive(Debug, FormData, PartialEq, Validate)]\n\tstruct Data {\n\t\t#[validate(length(max = 7))]\n\t\tdata: String\n\t}\n\n\twith_body(b\"data=shorter\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data {\n\t\t\tdata: \"shorter\".to_owned()\n\t\t})\n\t});\n\n\twith_body(b\"data=verylong\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state));\n\t\tassert!(matches!(data, Err(Error::InvalidData(_))));\n\t});\n}\n\n#[test]\nfn validate_min() {\n\t#[derive(Debug, FormData, PartialEq, Validate)]\n\tstruct Data {\n\t\t#[validate(range(min = 10))]\n\t\tdata: u64\n\t}\n\n\twith_body(b\"data=10\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data { data: 10 })\n\t});\n\n\twith_body(b\"data=9\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state));\n\t\tassert!(matches!(data, Err(Error::InvalidData(_))));\n\t});\n}\n\n#[test]\nfn validate_max() {\n\t#[derive(Debug, FormData, PartialEq, Validate)]\n\tstruct Data {\n\t\t#[validate(range(max = 10))]\n\t\tdata: u64\n\t}\n\n\twith_body(b\"data=10\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state)).unwrap();\n\t\tassert_eq!(data, Data { data: 10 })\n\t});\n\n\twith_body(b\"data=11\", APPLICATION_WWW_FORM_URLENCODED, |state| {\n\t\tlet data = block_on(Data::parse_form_data(state));\n\t\tassert!(matches!(data, Err(Error::InvalidData(_))));\n\t});\n}\n","traces":[],"covered":0,"coverable":0}]}